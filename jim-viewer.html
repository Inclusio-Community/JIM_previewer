<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JIM Metadata Viewer - Accessible SVG Analysis Tool</title>
    <style>
        :root {
            /* Color tokens */
            --bg-page: #f5f7fa;
            --text-normal: #1e293b;
            --muted: #64748b;
            /* Higher-contrast muted token for small/italic notes (helps Lighthouse) */
            --muted-contrast: #334155;
            --metadata-bg: #ffffff;
            --metadata-border: #e6eef6;
            --status-error: #dc2626; /* brighter red (Tailwind red-600) */
            --status-warning: #b45309; /* brighter orange (Tailwind amber-600) */
            --status-success: #065f46; /* darker emerald green for WCAG contrast */
            --badge-bg-jim: #047857;
            --badge-bg-nojim: #334155;
            /* High-contrast link color for small inline controls */
            --link: #0369a1;
        }
        /* Utility classes extracted from repeated inline styles (Batch A) */
        .muted { color: var(--muted); }
        .muted-italic { color: var(--muted); font-style: italic; }
        .spec-heading { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--metadata-border); font-size: 15px; color: var(--text-normal); }
        .inventory-button { background: #f8fafc; border: 1px solid #e2e8f0; padding: 8px; border-radius: 4px; font-size: 12px; cursor: pointer; box-sizing: border-box; display: inline-block; vertical-align: top; margin-bottom: 4px; color: var(--text-normal); }
        /* Ensure inventory buttons receive a visible highlight when focused (keyboard) or clicked (mouse).
           Some browsers suppress focus outlines on mouse interaction; add explicit :active and :focus styles
           so clicking or keyboard navigation both give a clear visual state. */
        .inventory-button:focus, .inventory-button:active, .inventory-button:focus-visible {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
            box-shadow: none;
        }
    .warning-text { color: var(--status-warning); }
        .status-success-line { color: var(--status-success); margin:4px 0; font-weight:600; }
        .status-warning-line { color: var(--status-warning); margin:4px 0; }
        .status-error-line { color: var(--status-error); margin:4px 0; }
        /* Status icons (use symbol fonts to avoid color-emoji rendering so axe can compute contrast) */
        .status-icon {
            font-family: "Segoe UI Symbol", "Segoe UI", "Arial", sans-serif;
            font-weight: 700;
            line-height: 1;
            display: inline-block;
            vertical-align: middle;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            /* ensure color is inherited from the status line (do not set a separate color) */
            color: inherit;
            margin-right: 6px;
        }
            /* Spec compliance box variants (used in metadata summary) */
            .spec-box { padding: 12px 16px; border-radius: 6px; margin-bottom: 16px; }
            .spec-box--error { background: #fee2e2; border: 1px solid #dc2626; }
            .spec-box--warning { background: #fef9c3; border: 1px solid #f59e0b; }
            .spec-box--success { background: #dcfce7; border: 1px solid #22c55e; }
            .spec-box-heading { font-size: 15px; }
            /* Let spec-box variants control heading color */
            .spec-box--error .spec-box-heading { color: var(--status-error); }
            .spec-box--warning .spec-box-heading { color: var(--status-warning); }
            .spec-box--success .spec-box-heading { color: var(--status-success); }
            .spec-box-list { margin: 8px 0 0 18px; padding: 0; }
            .spec-box-fixes { color: var(--status-success); font-size: 12px; margin-top: 8px; font-weight: 600; }
            /* Announcement variants used inside element info panels */
            .announcement-note { margin-top:8px; padding:8px; background:#f1f5f9; border-left:4px solid #64748b; border-radius:4px; }
            .announcement-success { margin-top:12px; padding:10px; background:#f0fdf4; border-left:4px solid #10b981; border-radius:4px; }
                /* Canonical panels, buttons and reusable fragments (consolidation) */
                .panel { padding: 12px 16px; border-radius: 6px; margin-bottom: 16px; background: var(--metadata-bg); border: 1px solid var(--metadata-border); }
                .panel--error { background: #fee2e2; border-color: #dc2626; }
                .panel--warning { background: #fffbeb; border-color: #f59e0b; }
                .panel--success { background: #ecfdf5; border-color: #10b981; }
                .panel__heading { font-size: 15px; color: var(--text-normal); margin-bottom:8px; }
                .btn { display: inline-flex; align-items: center; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:13px; margin-bottom:6px; border:1px solid transparent; background: #e6eef6; color: var(--text-normal); }
                .btn:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
                /* Small variant/placement tweaks for the overlay toggle near the visualization heading */
                .jim-overlay-toggle { margin-top:8px; margin-left:8px; }
                .btn:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
                .btn--selector { background: #e0e7ef; }
                .btn--selector--mapped { background: #d1fae5; border-color: #10b981; color: #022f26; }
                .btn--selector--group { background: #fef9c3; border-color: #f59e0b; color: #92400e; }
                .selector-panel { background: #f8fafc; border:1px solid #e2e8f0; border-radius:6px; padding:12px 16px; margin-bottom:8px; }
                .selector-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; margin-bottom:12px; }
                /* Main selector panel title (larger) vs subgroup headings (smaller) */
                .selector-panel > h2.panel__heading { font-size: 18px; margin-top: 0; margin-bottom: 10px; }
                /* Ensure subgroup headings inside selector panels have breathing room */
                .selector-panel .panel__heading { margin-top:12px; margin-bottom:8px; font-size:14px; }
                .badge { padding:2px 6px; border-radius:3px; font-size:11px; display:inline-block; vertical-align:middle; margin-left:4px; color: #fff; }
                .badge--jim { background: var(--badge-bg-jim); }
                .badge--nojim { background: var(--badge-bg-nojim); }
                .snippet { background:#f8fafc; padding:8px; border-radius:4px; margin-top:6px; max-height:120px; overflow:auto; }
                .snippet--error { background:#fff0f0; color:var(--status-error); }
                .muted-note { color: var(--muted-contrast); font-size:13px; margin-top:8px; }
                .computed-dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }
            .computed-dot-wrap { display:inline-flex; align-items:center; justify-content:center; width:16px; height:16px; border-radius:8px; margin-right:8px; vertical-align:middle; overflow:visible; }
            .computed-dot-swatch { width:10px; height:10px; border-radius:50%; display:block; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06); }
            .nojim-note { margin-top:8px; color:#334155; font-size:13px; }
        /* Orphaned selector card and meta text */
        .orphaned-item { background:#eff6ff; border-left:3px solid #3b82f6; padding:8px; margin:8px 0; border-radius:4px; font-size:13px; color:#1e293b; }
        .meta-text { color:#334155; font-size:12px; }
    /* Additional utility classes for consolidated inline styles */
    .hidden { display: none !important; }
    /* Section headings inside metadata panels: add a little more breathing room and subtle padding */
    .section-heading { margin-top: 22px; margin-bottom: 10px; padding-top: 6px; font-size:16px; color: #1f2937; }
    .wrap-chips { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:8px; }
    /* Group behavior layout helpers: wrap long selector text and allow chip scrolling */
    .group-behaviors-list { margin-top: 12px; display:flex; gap:12px; flex-wrap:wrap; }
    .group-behavior { margin-bottom: 8px; padding: 8px 12px; display: inline-block; vertical-align: top; box-sizing: border-box; width: auto; max-width: calc(100% - 24px); }
    .group-behavior-row { display:flex; align-items:flex-start; gap:8px; flex-wrap:wrap; }
    .group-behavior-row .btn { flex: 0 0 auto; }
    .group-selector-text { white-space: normal; word-break: break-word; max-width: calc(100% - 140px); display:block; flex: 1 1 auto; text-align:left; }
    .group-preview-row { display:flex; align-items:flex-start; gap:8px; }
    /* Wrap chips to multiple rows instead of horizontal scrolling */
    .group-preview-chips { display:flex; gap:6px; padding-top:8px; padding-bottom:4px; align-items:center; flex-wrap:wrap; }
    .group-preview-chips .inventory-button { flex: 0 0 auto; margin-right:6px; margin-bottom:6px; }
    .inline-row { display:inline-flex; align-items:center; }
    .inline-code { color:var(--text-normal); }
    .inline-text { color:var(--text-normal); margin-top:4px; }
    .details--spaced { margin-top:10px; }
    .pre-meta { background:#f8fafc; padding:8px; border-radius:4px; margin-top:6px; }
                /* JIM shape overlay visuals (invisible by default; highlight on hover/focus)
                     Toggle behavior:
                         - .jim-overlays-visible on #visualization forces overlays visible (stroke shown)
                         - .jim-overlays-hidden on #visualization forces overlays hidden except on hover/focus
                */
                .jim-shape-overlay { fill: transparent; stroke-opacity: 0; pointer-events: all; cursor: pointer; transition: stroke-opacity .12s ease, filter .12s ease; }
                .jim-shape-overlay:focus, .jim-shape-overlay:hover { stroke-opacity: 0.95; filter: drop-shadow(0 1px 4px rgba(0,0,0,0.12)); outline: none; }
                /* Visible state: force overlays visible */
                .jim-overlays-visible .jim-shape-overlay { stroke-opacity: 0.95; }
                /* Hidden state: keep overlays visually hidden but allow hover/focus to show them */
                .jim-overlays-hidden .jim-shape-overlay { stroke-opacity: 0; }
                .jim-overlays-hidden .jim-shape-overlay:hover,
                .jim-overlays-hidden .jim-shape-overlay:focus { stroke-opacity: 0.95; filter: drop-shadow(0 1px 4px rgba(0,0,0,0.12)); }
    .badge--muted { background:#e0e7ef; color:#1e293b; padding:2px 6px; margin-right:4px; }
    .muted-note.italic { font-style: italic; color: var(--muted-contrast); }
    .orphaned-list { padding-left:0; margin:8px 0; list-style:none; }
    .details-summary { cursor: pointer; color: var(--link); text-decoration: underline; }
    .details-summary:focus {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
    }
    .error-box { background:#fee2e2; border:1px solid #dc2626; padding:12px 16px; border-radius:6px; margin-bottom:16px; }
    .error-text { color: var(--status-error); font-size:15px; }
        * { box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f7fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #1e293b;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #1e293b;
            margin-bottom: 30px;
        }

        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: #1e40af;
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
        }

        .skip-link:focus {
            top: 6px;
        }

        .input-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .file-input-wrapper {
            margin-bottom: 15px;
            display: block;
        }

        .file-input-wrapper label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #334155;
        }

        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #cbd5e1;
            border-radius: 6px;
            cursor: pointer;
            background: white;
        }

        /* Layout row next to file input to show the current file (hides browser's default filename text) */
    .file-input-row { display: flex; align-items: center; gap: 12px; }
        /* Some browsers insert a pseudo-element showing the chosen file; hide that where possible */
        input[type='file']::-webkit-file-upload-text { display: none; }
        input[type='file']::-webkit-file-upload-button { display: inline-block; }
        input[type='file']::file-selector-button { display: inline-block; }
    #current-file { font-size: 13px; color: #475569; }

    /* Use the browser's native file input so freeform typing and native behaviors are preserved */
    input[type="file"] { display: inline-block; }
    .file-input-row { display: flex; align-items: center; gap: 12px; }
    #current-file { font-size: 13px; color: #475569; user-select: text; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        input[type="file"]:hover {
            border-color: #3b82f6;
        }

        input[type="file"]:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .file-help {
            font-size: 14px;
            color: #64748b;
            margin-top: 5px;
        }

        /* Default current-file styling (used outside chooser if present) */
        #current-file {
            font-size: 13px;
            color: #475569;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* Make the chooser full width and render filename inline next to the button */
        .file-chooser { width: 100%; box-sizing: border-box; }
    .file-chooser #current-file { display: inline-flex; align-items: center; margin-top: 0; max-width: calc(100% - 140px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-left:6px; }

        .viewer-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 400px;
        }

        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 20px;
            min-width: 280px;
            max-width: 400px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            z-index: 1000;
        }

        .info-panel.visible {
            display: block;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e2e8f0;
        }

        .info-panel-header h3 {
            margin: 0;
            font-size: 16px;
            color: #1e293b;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #1e293b; /* darker for measurable contrast */
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover, .close-btn:focus {
            color: #1e293b;
            outline: 2px solid #3b82f6;
            border-radius: 4px;
        }

        .info-content {
            font-size: 14px;
            color: #475569;
        }

        .info-content div {
            margin-bottom: 8px;
        }

        .info-content strong {
            color: #1e293b;
        }

        .info-content code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
        }

        .announcement {
            background: #f0f9ff;
            border-left: 3px solid #3b82f6;
            padding: 8px 12px;
            margin-top: 12px;
            border-radius: 4px;
        }

        #visualization {
            width: 100%;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #visualization svg {
            max-width: 100%;
            height: auto;
        }

        .empty-state {
            text-align: center;
            color: #94a3b8;
            padding: 60px 20px;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state p {
            color: #475569; /* darker muted color for WCAG contrast */
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Minimal fallback styles */
        svg * {
            cursor: pointer;
        }

        svg *:focus {
            outline: 2px solid #f59e0b;
            outline-offset: 2px;
        }

        .metadata-summary {
            /* Faint panel background to match the selectors box */
            background: #f8fafc; /* same as .selector-panel */
            border: 1px solid #e2e8f0; /* subtle cool border for separation */
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 20px;
            color: var(--text-normal);
        }

        /* Tighter visual separation and improved readability for the validation block */
        .metadata-summary .section-heading {
            border-top: 1px solid var(--metadata-border);
            padding-top: 8px;
            margin-top: 14px;
            margin-bottom: 8px;
            color: #0f172a; /* slightly darker for emphasis */
            font-weight: 700;
        }

        /* Make long validation lines easier to scan and wrap long comma-separated lists */
        .metadata-summary .status-warning-line,
        .metadata-summary .status-success-line,
        .metadata-summary .status-error-line,
        .metadata-summary .muted-note {
            line-height: 1.6;
            margin-top: 6px;
            white-space: normal;
            word-break: break-word;
        }

        .metadata-summary h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #1e293b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metadata-item {
            display: flex;
            padding: 4px 0;
        }

        .metadata-item .key {
            font-weight: 500;
            color: #475569;
            min-width: 120px;
        }

        .metadata-item .value {
            color: #1e293b;
        }

        .status-message {
            background: #fff7ed;
            border: 1px solid #f59e0b;
            color: #7c2d12; /* darker text for better contrast */
            padding: 12px 16px;
            border-radius: 6px;
            margin: 16px 0;
        }
    </style>
    <script>
        // Small inline SVG icons (fill uses currentColor so they inherit text color)
        const ICONS = {
            check: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>`,
            cross: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`,
            warn: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`,
            idea: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M9 21h6v-1H9v1zm3-19C8.48 2 5 5.48 5 9c0 2.5 1.5 4.66 3.79 5.5.21.09.36.29.36.52V17h6V15.02c0-.23.15-.43.36-.52C17.5 13.66 19 11.5 19 9c0-3.52-3.48-7-7-7z"/></svg>`,
            group: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5s-3 1.34-3 3 1.34 3 3 3zM8 11c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5C15 14.17 10.33 13 8 13zm8 0c-.29 0-.62.02-.97.05C16.22 13.78 18 14.84 18 16v3h6v-2.5C24 14.17 19.33 13 16 13z"/></svg>`,
            info: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>`,
            arrowdown: `<svg class="status-icon" width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>`
        };
    </script>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <div class="container">
        <!-- Screen reader help for SVG navigation -->
        <div id="svg-sr-help" class="sr-only" aria-live="polite">
            Visualization area. Press 'i' to jump to the first available list (Spec Compliance and then Orphaned Selectors if present, otherwise SVG Element Inventory). In the SVG Element Inventory, use Tab to move between items and Enter to open details. The Spec Compliance and Orphaned Selectors lists are not interactive.
        </div>
        <header>
            <h1>JIM Metadata Viewer</h1>
            <p class="subtitle">Load and explore JSON for Interactive Media (JIM) documents</p>
        </header>

        <main id="main-content">
            <section class="input-section" aria-labelledby="upload-heading">
                <h2 id="upload-heading" class="sr-only">File Upload</h2>
                <div class="file-input-wrapper">
                    <label for="jim-file">Upload SVG or HTML file:</label>
                    <div class="file-input-row">
                        <input type="file" id="jim-file" accept=".svg,.html,.htm" aria-describedby="file-help">
                        <span id="current-file" class="sr-only" aria-live="polite">No file loaded</span>
                    </div>
                    <div id="file-help" class="file-help">Supported: SVG files (with or without JIM metadata) and HTML files containing SVG elements.</div>
                </div>
                <div id="metadata-summary" aria-live="polite"></div>
                <div id="status-messages" aria-live="polite" aria-atomic="true"></div>
            </section>

            <section id="selector-list-panel" class="selector-panel hidden"></section>
            <section class="viewer-section" aria-labelledby="visualization-heading">
                <h2 id="visualization-heading">Interactive Visualization</h2>
                <div id="visualization" aria-live="polite" tabindex="0">
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                        </svg>
                        <p>Upload a document to begin analysis</p>
                    </div>
                </div>
            </section>

                        <section class="viewer-section hidden" id="analysis-section" aria-labelledby="analysis-heading">
              <h2 id="analysis-heading">Detailed Analysis</h2>
                            <section id="analysis-content"></section>
            </section>
        </main>

    <aside id="info-panel" class="info-panel" aria-labelledby="element-info-heading" tabindex="-1">
            <div class="info-panel-header">
                <h3 id="element-info-heading">Element Information</h3>
                <button type="button" class="close-btn" aria-label="Close information panel">&times;</button>
            </div>
            <div id="info-content" class="info-content"></div>
        </aside>
        <!-- Move the live region outside the info panel for stability and visibility to SRs -->
        <div id="info-panel-live" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const viz = document.getElementById('visualization');
            const inventorySection = document.getElementById('analysis-section');
            if (viz && inventorySection) {
                viz.setAttribute('tabindex', '0'); // Make visualization focusable
                viz.addEventListener('keydown', function (e) {
                    if ((e.key === 'i' || e.key === 'I') && !e.altKey && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        // Try to focus the first inventory item
                        const firstItem = inventorySection.querySelector('li[tabindex]');
                        if (firstItem) {
                            firstItem.focus();
                        } else {
                            // If no item, focus the section heading
                            const heading = inventorySection.querySelector('h4, h5');
                            if (heading) heading.focus();
                        }
                    }
                });
            }
        });
                // --- Preflight JIM helper: robust, non-destructive normalization and validation ---
                function preflightJIM(rawJim, docContext) {
                    const errors = [];
                    const warnings = [];
                    const fixesApplied = [];
                    const jim = JSON.parse(JSON.stringify(rawJim || {})); // shallow clone

                    // — Required: version.jim
                    if (!jim?.version?.jim || typeof jim.version.jim !== 'string') {
                        errors.push("Missing required property: version.jim (string)");
                    }

                    // — Normalize datasets
                    if (!jim.datasets && jim.dataset) {
                        jim.datasets = [jim.dataset];
                        warnings.push("Found 'dataset' (singular); normalized to 'datasets[]'.");
                        fixesApplied.push("dataset→datasets[]");
                    }
                    if (jim.datasets && !Array.isArray(jim.datasets)) {
                        jim.datasets = [jim.datasets];
                        warnings.push("Found 'datasets' as object; wrapped in an array.");
                        fixesApplied.push("datasets{ }→datasets[ ]");
                    }
                    if (!jim.datasets || jim.datasets.length === 0) {
                        errors.push("Missing required property: datasets (array with at least one item).");
                    }

                    // — Required: selectors
                    if (!jim.selectors || typeof jim.selectors !== 'object' || Array.isArray(jim.selectors)) {
                        errors.push("Missing required property: selectors (object).");
                    } else {
                        for (const [key, sel] of Object.entries(jim.selectors)) {
                            if (!sel || typeof sel !== 'object') {
                                errors.push(`Selector '${key}' is not an object (found type: ${typeof sel}).`);
                                continue;
                            }
                            if (sel.jsonPath && !sel.json) {
                                sel.json = sel.jsonPath;
                                warnings.push(`Selector '${key}' used 'jsonPath'; normalized to 'json'.`);
                                fixesApplied.push("jsonPath→json");
                            }
                            if (typeof sel.dom !== 'string' || !sel.dom.trim()) {
                                errors.push(`Selector '${key}' missing 'dom' (string).`);
                            } else {
                                // Prefer to validate the selector using querySelector. If it throws,
                                // only then emit a helpful warning. This avoids false positives
                                // for valid descendant selectors such as '#y-axis g:nth-child(1) text'.
                                try {
                                    document.createElement('div').querySelector(sel.dom);
                                } catch (e) {
                                    // If the selector starts with '#' and contains a space, it's
                                    // commonly a user mistake (attempting to match an ID that
                                    // contains spaces). But it's also valid to have a selector
                                    // that begins with an ID and then uses descendant combinators.
                                    // Only warn about ID-with-spaces when querySelector actually
                                    // failed to parse the selector.
                                    if (sel.dom.startsWith('#') && sel.dom.includes(' ')) {
                                        warnings.push(`Selector '${key}' references an ID-like pattern with spaces ('${sel.dom}'). IDs cannot contain literal spaces — if you intended a descendant selector (e.g. '#y-axis g text') this is valid; otherwise consider renaming the SVG ID. Also: ${e.message}`);
                                    } else {
                                        warnings.push(`Selector '${key}' uses invalid CSS selector syntax ('${sel.dom}'): ${e.message}`);
                                    }
                                }
                            }
                            if (!('json' in sel)) {
                                errors.push(`Selector '${key}' missing 'json' property.`);
                            } else if (
                                !(typeof sel.json === 'string' && sel.json.trim()) &&
                                !(Array.isArray(sel.json) && sel.json.length > 0 && sel.json.every(j => typeof j === 'string' && j.trim()))
                            ) {
                                errors.push(`Selector '${key}' 'json' must be a non-empty string or array of non-empty strings.`);
                            }
                        }
                    }
                        // Warn if there are records but no facets defined
                        const hasFacets = jim.datasets && Array.isArray(jim.datasets) && jim.datasets[0] && jim.datasets[0].facets && Object.keys(jim.datasets[0].facets).length > 0;
                        const hasSeries = jim.datasets && Array.isArray(jim.datasets) && jim.datasets[0] && Array.isArray(jim.datasets[0].series) && jim.datasets[0].series.length > 0;
                        let hasRecords = false;
                        if (hasSeries) {
                            for (const s of jim.datasets[0].series) {
                                if (Array.isArray(s.records) && s.records.length > 0) {
                                    hasRecords = true;
                                    break;
                                }
                            }
                        }
                        if (!hasFacets && hasRecords) {
                            warnings.push("Records are present, but no facets are defined. Consider adding facet definitions for better semantic clarity and accessibility.");
                        }

                    // — Optional: behaviors (default to [])
                    if (!('behaviors' in jim)) {
                        jim.behaviors = [];
                        // info note; no warning to avoid noise
                    } else if (!Array.isArray(jim.behaviors)) {
                        warnings.push("Behaviors was not an array; normalized to empty array.");
                        fixesApplied.push("behaviors→[]");
                        jim.behaviors = [];
                    }
                        // — Validate behaviors structure and keys
                        if (Array.isArray(jim.behaviors)) {
                            // JIM spec event keys
                            const allowedBehaviorKeys = new Set(["target", "enter", "details", "activate", "exit", "note", "description", "id", "name"]);
                            const allowedEventKeys = new Set(["haptic", "haptic_pattern", "announcement", "notes", "note", "description", "id", "name", "audio"]);
                            const eventKeysSpec = ["enter", "details", "activate", "exit"];
                            jim.behaviors.forEach((b, i) => {
                                if (typeof b !== "object" || b === null) {
                                    errors.push(`Behavior[${i}] is not an object.`);
                                    return;
                                }
                                // Check for illegal keys
                                const keys = Object.keys(b);
                                const illegal = keys.filter(k => !allowedBehaviorKeys.has(k));
                                if (illegal.length) {
                                    errors.push(`Behavior[${i}] has illegal/non-standard key(s): ${illegal.join(", ")}`);
                                }
                                // Require 'target'
                                if (!('target' in b)) {
                                    errors.push(`Behavior[${i}] missing required 'target' property.`);
                                } else if (typeof b.target !== "object" || b.target === null) {
                                    errors.push(`Behavior[${i}] 'target' must be an object.`);
                                } else {
                                    // Accept either selector-based targets OR shapes-array-based targets
                                    const tgt = b.target || {};
                                    const hasSelector = typeof tgt.selector === 'string' && tgt.selector.trim();
                                    const hasShapesArray = Array.isArray(tgt.shapes) && tgt.shapes.length > 0;
                                    if (!hasSelector && !hasShapesArray) {
                                        errors.push(`Behavior[${i}] target must include either 'selector' (non-empty string) or 'shapes' (non-empty array).`);
                                    } else {
                                        // Flag non-standard keys in target but allow selector/id/name/shapes
                                        const allowedTargetKeys = new Set(["selector", "id", "name", "shapes"]);
                                        const targetKeys = Object.keys(tgt);
                                        const illegalTargetKeys = targetKeys.filter(k => !allowedTargetKeys.has(k));
                                        if (illegalTargetKeys.length) {
                                            warnings.push(`Behavior[${i}] target has non-standard key(s): ${illegalTargetKeys.join(", ")}`);
                                        }
                                        // If shapes array is present, validate each shape object's structure
                                        if (hasShapesArray) {
                                            const allowedShapeKinds = new Set(['rect','rectangle','circle','ellipse','line','polygon','polyline','path']);
                                            tgt.shapes.forEach((shapeObj, sIdx) => {
                                                if (!shapeObj || typeof shapeObj !== 'object' || Array.isArray(shapeObj)) {
                                                    errors.push(`Behavior[${i}] target.shapes[${sIdx}] must be an object (found ${typeof shapeObj}).`);
                                                    return;
                                                }
                                                const kindKeys = Object.keys(shapeObj);
                                                if (kindKeys.length !== 1) {
                                                    errors.push(`Behavior[${i}] target.shapes[${sIdx}] must contain exactly one shape kind key (found ${kindKeys.length}).`);
                                                    return;
                                                }
                                                // Normalize alias 'rectangle' -> 'rect' for validation messages
                                                let kind = kindKeys[0];
                                                const originalKind = kind;
                                                if (kind === 'rectangle') kind = 'rect';
                                                if (!allowedShapeKinds.has(kind)) {
                                                    errors.push(`Behavior[${i}] target.shapes[${sIdx}] has unknown shape kind '${originalKind}'. Allowed kinds: ${[...allowedShapeKinds].join(', ')}.`);
                                                    return;
                                                }
                                                const payload = shapeObj[kindKeys[0]];
                                                if (!payload || typeof payload !== 'object') {
                                                    errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind} must be an object with shape properties.`);
                                                    return;
                                                }
                                                const isNumericLike = (v) => (typeof v === 'number' && Number.isFinite(v)) || (typeof v === 'string' && v.trim() !== '' && !Number.isNaN(Number(v)));
                                                const checkNumberProp = (propName) => {
                                                    if (!(propName in payload)) {
                                                        errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.${propName} is required.`);
                                                    } else if (!isNumericLike(payload[propName])) {
                                                        errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.${propName} must be a number.`);
                                                    } else if (typeof payload[propName] === 'string') {
                                                        warnings.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.${propName} is a string; expected a numeric type.`);
                                                    }
                                                };

                                                switch (kind) {
                                                    case 'rect':
                                                        ['x','y','width','height'].forEach(checkNumberProp);
                                                        break;
                                                    case 'circle':
                                                        ['cx','cy','r'].forEach(checkNumberProp);
                                                        break;
                                                    case 'ellipse':
                                                        ['cx','cy','rx','ry'].forEach(checkNumberProp);
                                                        break;
                                                    case 'line':
                                                        ['x1','y1','x2','y2'].forEach(checkNumberProp);
                                                        break;
                                                    case 'polygon':
                                                    case 'polyline':
                                                        if (!('points' in payload)) {
                                                            errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.points is required.`);
                                                        } else {
                                                            const pts = payload.points;
                                                            if (typeof pts === 'string') {
                                                                if (!pts.trim()) errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.points must be a non-empty string.`);
                                                            } else if (Array.isArray(pts)) {
                                                                if (pts.length === 0) {
                                                                    errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.points must be a non-empty array.`);
                                                                } else {
                                                                    pts.forEach((p, pi) => {
                                                                        if (!Array.isArray(p) || p.length < 2 || !isNumericLike(p[0]) || !isNumericLike(p[1])) {
                                                                            errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.points[${pi}] must be a pair of numbers [x,y].`);
                                                                        } else if (typeof p[0] === 'string' || typeof p[1] === 'string') {
                                                                            warnings.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.points[${pi}] uses string values; numeric types are preferred.`);
                                                                        }
                                                                    });
                                                                }
                                                            } else {
                                                                errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.points must be a string or array of point pairs.`);
                                                            }
                                                        }
                                                        break;
                                                    case 'path':
                                                        if (!('d' in payload) || typeof payload.d !== 'string' || !payload.d.trim()) {
                                                            errors.push(`Behavior[${i}] target.shapes[${sIdx}].${originalKind}.d is required and must be a non-empty string.`);
                                                        }
                                                        break;
                                                    default:
                                                        // no-op for kinds already validated above
                                                        break;
                                                }
                                            });
                                        }
                                    }
                                }
                                // Check event blocks (enter, details, activate, exit)
                                eventKeysSpec.forEach(eventName => {
                                    const block = b[eventName];
                                    if (block !== undefined) {
                                        if (!block || typeof block !== 'object') {
                                            errors.push(`Behavior[${i}] ${eventName} is not an object.`);
                                            return;
                                        }
                                        if ('haptic_pattern' in block && typeof block.haptic_pattern === 'string') {
                                            warnings.push(`Behavior[${i}] ${eventName}.haptic_pattern uses deprecated string syntax; should be an object.`);
                                        }
                                        if ('announcement' in block && typeof block.announcement === 'string') {
                                            warnings.push(`Behavior[${i}] ${eventName}.announcement uses deprecated string syntax; should be an object.`);
                                        }
                                            // Announcement block validation (JIM spec)
                                            if ('announcement' in block && typeof block.announcement === 'object' && block.announcement !== null) {
                                                const ann = block.announcement;
                                                const annKeys = Object.keys(ann);
                                                const allowedAnnKeys = new Set(['name', 'description', 'details', 'hint']);
                                                const unknownAnnKeys = annKeys.filter(k => !allowedAnnKeys.has(k));
                                                if (unknownAnnKeys.length) {
                                                    warnings.push(`Behavior[${i}] ${eventName}.announcement has unknown/non-standard key(s): ${unknownAnnKeys.join(", ")}`);
                                                }
                                                annKeys.forEach(k => {
                                                    if (!allowedAnnKeys.has(k)) return;
                                                    const v = ann[k];
                                                    if (typeof v !== 'string' || !v.trim()) {
                                                        errors.push(`Behavior[${i}] ${eventName}.announcement.${k} must be a non-empty string.`);
                                                    }
                                                    // Warn if value looks like a template (contains curly braces)
                                                    if (typeof v === 'string' && /\{.*\}/.test(v)) {
                                                        warnings.push(`Behavior[${i}] ${eventName}.announcement.${k} appears to use dynamic/template syntax ('${v}'), which is not currently supported by the JIM spec.`);
                                                    }
                                                });
                                            } else if ('announcement' in block && typeof block.announcement === 'object' && block.announcement !== null && Object.keys(block.announcement).length === 0) {
                                                warnings.push(`Behavior[${i}] ${eventName}.announcement block is present but empty.`);
                                            }
                                        // Check for unknown keys in event block
                                        const eventKeys = Object.keys(block);
                                        const unknownEventKeys = eventKeys.filter(k => !allowedEventKeys.has(k));
                                        if (unknownEventKeys.length) {
                                            warnings.push(`Behavior[${i}] ${eventName} has unknown/non-standard key(s): ${unknownEventKeys.join(", ")}`);
                                        }
                                            // Haptic block validation (JIM spec)
                                            if ('haptic' in block) {
                                                const haptic = block.haptic;
                                                if (!haptic || typeof haptic !== 'object') {
                                                    errors.push(`Behavior[${i}] ${eventName}.haptic is not an object.`);
                                                } else {
                                                    const hapticKeys = Object.keys(haptic);
                                                    const allowedHapticKeys = new Set(['durations', 'intensities', 'repeatInterval', 'repeatIndex']);
                                                    const unknownHapticKeys = hapticKeys.filter(k => !allowedHapticKeys.has(k));
                                                    if (unknownHapticKeys.length) {
                                                        warnings.push(`Behavior[${i}] ${eventName}.haptic has unknown/non-standard key(s): ${unknownHapticKeys.join(", ")}`);
                                                    }
                                                        // Audio block validation (object form)
                                                        if ('audio' in block) {
                                                            const audio = block.audio;
                                                            if (!audio || typeof audio !== 'object') {
                                                                warnings.push(`Behavior[${i}] ${eventName}.audio should be an object with an 'href' property.`);
                                                            } else {
                                                                const audioKeys = Object.keys(audio);
                                                                const allowedAudioKeys = new Set(['href', 'repeat', 'loop']);
                                                                const unknownAudioKeys = audioKeys.filter(k => !allowedAudioKeys.has(k));
                                                                if (unknownAudioKeys.length) {
                                                                    warnings.push(`Behavior[${i}] ${eventName}.audio has unknown/non-standard key(s): ${unknownAudioKeys.join(', ')}`);
                                                                }
                                                                if (!('href' in audio) || typeof audio.href !== 'string' || !audio.href.trim()) {
                                                                    warnings.push(`Behavior[${i}] ${eventName}.audio.href should be a non-empty string (filename or URL).`);
                                                                }
                                                                if ('repeat' in audio && typeof audio.repeat !== 'string') {
                                                                    warnings.push(`Behavior[${i}] ${eventName}.audio.repeat should be a string (e.g. 'none' or 'loop').`);
                                                                }
                                                            }
                                                        }
                                                    if (!('durations' in haptic)) {
                                                        errors.push(`Behavior[${i}] ${eventName}.haptic missing required 'durations' key.`);
                                                    } else if (!Array.isArray(haptic.durations)) {
                                                        errors.push(`Behavior[${i}] ${eventName}.haptic.durations is not an array.`);
                                                    }
                                                }
                                            }
                                    }
                                });
                            });
                        }

                    // — Conditional cross-refs (only if behaviors present)
                        // — Conditional cross-refs (only if behaviors present)
                        // Use provided docContext, fallback to a global currentDoc if present, else document
                        if (Array.isArray(jim.behaviors) && jim.behaviors.length > 0 && jim.selectors && typeof window !== 'undefined') {
                            const doc = (typeof docContext !== 'undefined' && docContext) ? docContext : ((typeof currentDoc !== 'undefined' && currentDoc) ? currentDoc : document);
                            let svg = null;
                            try {
                                svg = doc.querySelector('svg');
                            } catch {}
                            if (svg) {
                                jim.behaviors.forEach((b, i) => {
                                            const rawTgt = b?.target?.selector;
                                            if (typeof rawTgt === 'string' && rawTgt.trim()) {
                                                // Normalize selector: trim and strip surrounding quotes if present
                                                let tgt = rawTgt.trim();
                                                if ((tgt.startsWith('"') && tgt.endsWith('"')) || (tgt.startsWith("'") && tgt.endsWith("'"))) {
                                                    tgt = tgt.slice(1, -1).trim();
                                                }
                                                // Now test the selector using querySelectorAll to get an accurate match count
                                                try {
                                                    let count = 0;
                                                    // If the selector looks like a comma-separated list of ID selectors
                                                    // (e.g. '#a, #b, #c'), test each id individually with getElementById
                                                    // because some engines or contexts may treat the combined selector
                                                    // differently during preflight.
                                                    if (tgt.includes(',') && tgt.split(',').every(s => /^\s*#[A-Za-z0-9_:-]+\s*$/.test(s))) {
                                                        const parts = tgt.split(',').map(s => s.trim());
                                                        parts.forEach(p => {
                                                            try {
                                                                const id = p.slice(1);
                                                                if (svg.getElementById && svg.getElementById(id)) count++;
                                                            } catch (_) { }
                                                        });
                                                    } else {
                                                        const nodes = Array.from(svg.querySelectorAll(tgt));
                                                        count = nodes.length;
                                                    }
                                                    if (count === 0) {
                                                        warnings.push(`Behavior[${i}] target.selector '${rawTgt}' did not match any SVG DOM elements (tested '${tgt}': ${count} matches).`);
                                                    }
                                                } catch (e) {
                                                    // Invalid selector syntax — surface a clearer message
                                                    warnings.push(`Behavior[${i}] target.selector '${rawTgt}' appears to be invalid CSS selector syntax: ${e.message}`);
                                                }
                                            }
                                        });
                            }
                        }

                    // — Soft checks on datasets[0]
                    const ds0 = jim.datasets && jim.datasets[0];
                    if (ds0 && (ds0.series && !Array.isArray(ds0.series))) {
                        warnings.push("datasets[0].series is not an array.");
                    }
                    if (ds0 && !ds0.series) {
                        warnings.push("datasets[0].series missing; continuing without series.");
                    }

                    // — Unknown top-level keys (informative, spec-aligned)
                    // See: https://inclusio-community.github.io/json-image-metadata
                    const allowedTop = new Set([
                        'version',
                        'datasets',
                        'dataset',
                        'selectors',
                        'behaviors',
                        'metadata',
                        'name',
                        'id',
                        'description',
                        'license',
                        'attribution',
                        'source',
                        'created',
                        'modified',
                        'tags',
                        'thumbnail',
                        'links',
                        'schema',
                        'notes',
                        'examples',
                        'summary',
                        'credits',
                        'language',
                        'publisher',
                        'contributor',
                        'related',
                        'external',
                        'profile',
                        'type',
                        'title',
                        'status',
                        'accessibility',
                        'audience',
                        'keywords',
                        'coverage',
                        'spatial',
                        'temporal',
                        'rights',
                        'identifier',
                        'isPartOf',
                        'hasPart',
                        'references',
                        'isReferencedBy',
                        'format',
                        'extent',
                        'provenance',
                        'funding',
                        'contact',
                        'seeAlso',
                        'alternate',
                        'encoding',
                        'media',
                        'data',
                        'custom',
                        // Add any other spec keys as needed
                    ]);
                    const unknown = Object.keys(jim).filter(k => !allowedTop.has(k));
                    if (unknown.length) {
                        warnings.push(`Non-standard top-level fields: ${unknown.join(', ')}`);
                    }

                    return { ok: errors.length === 0, errors, warnings, fixesApplied, normalizedJim: jim };
                }

                class JIMViewer {
    // Robust JSONPath lookup for JIM metadata (supports $.foo[0].bar)
    getDataFromJSONPath(path) {
        if (!path || !this.jimData) return null;
        // If path is an array, resolve each and merge results
        if (Array.isArray(path)) {
            const results = path.map(p => this.getDataFromJSONPath(p)).filter(v => v !== null && v !== undefined);
            if (results.length === 0) return null;
            if (results.every(v => typeof v !== 'object' || v === null)) return results;
            return [].concat(...results.map(v => Array.isArray(v) ? v : [v]));
        }
        if (typeof path === 'string' && path.includes(',')) {
            // Support comma-separated paths as array
            const paths = path.split(',').map(p => p.trim()).filter(Boolean);
            return this.getDataFromJSONPath(paths);
        }
        if (typeof path !== 'string') return null;
        let val = this.jimData;
        // Wildcard support: if path ends with .* return all key-value pairs
        let wildcard = false;
        let pathStr = path;
        if (path.endsWith('.*')) {
            wildcard = true;
            pathStr = path.slice(0, -2);
        }
        // Remove leading $. and convert [n] to .n for easier splitting
        const parts = pathStr.replace(/^\$\./, '').replace(/\[(\d+)\]/g, '.$1').split('.');
        for (const key of parts) {
            if (val && key in val) val = val[key];
            else if (Array.isArray(val) && !isNaN(Number(key))) val = val[Number(key)];
            else return null;
        }
        if (wildcard && val && typeof val === 'object') {
            // Return all key-value pairs as a flat object
            return Object.assign({}, val);
        }
        return val;
    }
    // Insert the SVG into the visualization container and set up event handlers
    displayVisualization(svgClone) {
        const container = document.getElementById('visualization');
        if (container) {
            container.innerHTML = '';
            container.appendChild(svgClone);
            // After inserting the visualization, ensure the overlay toggle exists
            try {
                if (typeof this._ensureOverlayToggle === 'function') this._ensureOverlayToggle();
            } catch (e) { /* ignore */ }
            // Map any stored inventoryData.domElement references (which may point to
            // elements in the parsed document) to the corresponding elements in the
            // newly-inserted cloned SVG so inventory clicks target live DOM nodes.
            try {
                const viz = container;
                if (viz && Array.isArray(this.inventoryData) && this.inventoryData.length) {
                    this.inventoryData.forEach(item => {
                        try {
                            if (!item || !item.domElement) return;
                            // Prefer mapping by element ID when available
                            let mapped = null;
                            const original = item.domElement;
                            if (original && original.id) {
                                try {
                                    if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
                                        mapped = viz.querySelector('#' + CSS.escape(original.id));
                                    } else {
                                        mapped = viz.querySelector('#' + original.id);
                                    }
                                } catch (e) { mapped = null; }
                            }
                            // Next try any stored selector string
                            if (!mapped && item.selector) {
                                try { mapped = viz.querySelector(item.selector); } catch (e) { mapped = null; }
                            }
                            // Fallback: try basic tag+class matching
                            if (!mapped && original && original.tagName) {
                                try {
                                    const tag = original.tagName.toLowerCase();
                                    const cls = (original.classList && original.classList.length) ? Array.from(original.classList) : [];
                                    const candidates = Array.from(viz.querySelectorAll(tag));
                                    if (cls.length) {
                                        mapped = candidates.find(c => cls.every(cn => c.classList && c.classList.contains(cn)));
                                    } else if (candidates.length === 1) {
                                        mapped = candidates[0];
                                    }
                                } catch (e) { mapped = null; }
                            }
                            if (mapped) item.domElement = mapped;
                        } catch (e) { /* per-item mapping failures are non-fatal */ }
                    });
                }
            } catch (e) { /* ignore mapping failures */ }
        }
    }

    // Render the SVG, attach JIM behaviors (including wildcards), and fallback click handler
    renderVisualization() {
        const svg = this.currentDoc.querySelector('svg');
        if (!svg) {
            this.showError('No SVG found in document');
            return;
        }
        // Clone the SVG to avoid modifying the original document
        const svgClone = svg.cloneNode(true);
        const selectors = this.jimData.selectors || {};
        const behaviors = this.jimData.behaviors || [];

        // Attach JIM behaviors to elements that have selectors (legacy direct mapping)
        Object.entries(selectors).forEach(([key, selector]) => {
            let element = null;
            try {
                element = svgClone.querySelector(selector.dom);
            } catch (e) {
                console.warn(`[JIMViewer] Invalid selector for key '${key}' in renderVisualization: '${selector.dom}'`, e);
                return; // skip this selector
            }
            if (element) {
                this.attachJIMBehavior(element, key);
            }
        });

        // Attach behaviors using target.selector (supports wildcards/classes)
        behaviors.forEach((behavior, i) => {
            const tgtSelector = behavior?.target?.selector;
            if (typeof tgtSelector === 'string' && tgtSelector.trim()) {
                let elements = [];
                try {
                    elements = Array.from(svgClone.querySelectorAll(tgtSelector));
                } catch (e) {
                    console.warn(`[JIMViewer] Invalid behavior target.selector '${tgtSelector}'`, e);
                }
                elements.forEach((el, idx) => {
                    // Attach behavior event listeners with TRACE logs
                    el.addEventListener('focus', () => {
                        this.showElementInfoByBehavior(behavior, 'focus', el);
                    });
                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.showElementInfoByBehavior(behavior, 'click', el);
                    });
                });
            }
        });

        // Add fallback handler for ANY SVG element (for elements without JIM mappings)
        // Enhanced: walk up from the event target to find any matching behavior selector
        svgClone.addEventListener('click', (e) => {
            const targetElement = e.target;
            if (!(targetElement instanceof SVGElement) || targetElement === svgClone) return;

            // First: check if any behavior selector matches the target or its ancestors up to the svgClone
            let matched = false;
            try {
                for (let bi = 0; bi < behaviors.length && !matched; bi++) {
                    const behavior = behaviors[bi];
                    const tgtSelector = behavior?.target?.selector;
                    if (!tgtSelector) continue;

                    // Walk up from the clicked element to the svg root, checking .matches at each step
                    let current = targetElement;
                    while (current && current !== svgClone && !matched) {
                        try {
                            if (current.matches && current.matches(tgtSelector)) {
                                // Found a parent (or the element itself) that the behavior targets
                                e.stopPropagation();
                                try { this.showElementInfoByBehavior(behavior, 'click', current); } catch (err) { this.showBehaviorInfo(behavior, 'click', current); }
                                matched = true;
                                break;
                            }
                        } catch (err) {
                            // invalid selector or other error: ignore and continue up the tree
                        }
                        current = current.parentElement;
                    }
                }
            } catch (err) {
                // If anything goes wrong, fall back to original behavior
                matched = false;
            }

            if (matched) return;

            // If no behavior selector matched, fall back to showing non-JIM element info when appropriate
            const selectors = this.jimData?.selectors || {};
            const hasJIM = Object.values(selectors).some(s => {
                try { return targetElement.matches(s.dom); } catch { return false; }
            });
            if (!hasJIM) this.showNonJIMElementInfo(targetElement, 'click');
        });

        // Render overlays for behavior.target.shapes (if present)
        try {
            const ns = 'http://www.w3.org/2000/svg';
            let overlayGroup = svgClone.querySelector('g.jim-overlays');
            if (!overlayGroup) {
                overlayGroup = document.createElementNS(ns, 'g');
                overlayGroup.classList.add('jim-overlays');
                // Put overlays on top
                svgClone.appendChild(overlayGroup);
            }
            // Ensure inventoryData exists and is in-sync
            if (!this.inventoryData) this.inventoryData = [];
            // For each behavior, create overlays and attach handlers
            (this.jimData.behaviors || []).forEach((behavior, bi) => {
                const shapes = Array.isArray(behavior?.target?.shapes) ? behavior.target.shapes : [];
                shapes.forEach((shapeObj, si) => {
                    if (!shapeObj || typeof shapeObj !== 'object') return;
                    const kindKeys = Object.keys(shapeObj); if (!kindKeys.length) return;
                    let kind = kindKeys[0]; if (kind === 'rectangle') kind = 'rect';
                    const payload = shapeObj[kindKeys[0]] || {};
                    let overlayEl = null;
                    try {
                        switch (kind) {
                            case 'rect':
                                overlayEl = document.createElementNS(ns, 'rect');
                                overlayEl.setAttribute('x', payload.x ?? 0);
                                overlayEl.setAttribute('y', payload.y ?? 0);
                                overlayEl.setAttribute('width', payload.width ?? 0);
                                overlayEl.setAttribute('height', payload.height ?? 0);
                                break;
                            case 'circle':
                                overlayEl = document.createElementNS(ns, 'circle');
                                overlayEl.setAttribute('cx', payload.cx ?? 0);
                                overlayEl.setAttribute('cy', payload.cy ?? 0);
                                overlayEl.setAttribute('r', payload.r ?? 0);
                                break;
                            case 'ellipse':
                                overlayEl = document.createElementNS(ns, 'ellipse');
                                overlayEl.setAttribute('cx', payload.cx ?? 0);
                                overlayEl.setAttribute('cy', payload.cy ?? 0);
                                overlayEl.setAttribute('rx', payload.rx ?? 0);
                                overlayEl.setAttribute('ry', payload.ry ?? 0);
                                break;
                            case 'line':
                                overlayEl = document.createElementNS(ns, 'line');
                                overlayEl.setAttribute('x1', payload.x1 ?? 0);
                                overlayEl.setAttribute('y1', payload.y1 ?? 0);
                                overlayEl.setAttribute('x2', payload.x2 ?? 0);
                                overlayEl.setAttribute('y2', payload.y2 ?? 0);
                                break;
                            case 'polygon':
                            case 'polyline':
                                overlayEl = document.createElementNS(ns, kind);
                                overlayEl.setAttribute('points', Array.isArray(payload.points) ? payload.points.map(p => p.join(',')).join(' ') : (payload.points || ''));
                                break;
                            case 'path':
                                overlayEl = document.createElementNS(ns, 'path');
                                overlayEl.setAttribute('d', payload.d || '');
                                break;
                            default:
                                break;
                        }
                    } catch (e) { overlayEl = null; }
                    if (!overlayEl) return;
                    overlayEl.classList.add('jim-shape-overlay');
                    // Apply any visual stroke/fill hints from the payload if present (non-destructive)
                    try {
                        // Basic attributes (support both kebab-case and camelCase keys)
                        const map = {
                            'stroke': 'stroke',
                            'stroke-width': 'stroke-width',
                            'strokeWidth': 'stroke-width',
                            'stroke-linecap': 'stroke-linecap',
                            'strokeLinecap': 'stroke-linecap',
                            'stroke-linejoin': 'stroke-linejoin',
                            'strokeLinejoin': 'stroke-linejoin',
                            'stroke-dasharray': 'stroke-dasharray',
                            'strokeDasharray': 'stroke-dasharray',
                            'stroke-opacity': 'stroke-opacity',
                            'strokeOpacity': 'stroke-opacity',
                            'fill': 'fill',
                            'fill-opacity': 'fill-opacity',
                            'fillOpacity': 'fill-opacity',
                            'opacity': 'opacity'
                        };
                        for (const k of Object.keys(map)) {
                            if (payload[k] !== undefined && payload[k] !== null) {
                                const attr = map[k];
                                const raw = String(payload[k]);
                                // Special-case fill: map explicit 'none' to 'transparent' to preserve pointer interactions
                                    if (attr === 'fill') {
                                    const v = raw;
                                    const mapped = (v === 'none') ? 'transparent' : v;
                                    // Set both the presentation attribute and an inline style
                                    overlayEl.setAttribute('fill', mapped);
                                    try { overlayEl.style.setProperty('fill', mapped); } catch (e) { /* ignore */ }
                                } else {
                                    // Apply as both attribute and inline style
                                    overlayEl.setAttribute(attr, raw);
                                    try {
                                        // Add 'px' unit for numeric stroke-width values when needed
                                        let styleVal = raw;
                                        if (attr === 'stroke-width') {
                                            if (/^\d+(?:\.\d+)?$/.test(raw)) styleVal = raw + 'px';
                                        }
                                        overlayEl.style.setProperty(attr, styleVal);
                                    } catch (e) { /* ignore */ }
                                }
                            }
                        }
                    } catch (e) { /* ignore */ }
                    overlayEl.setAttribute('fill', overlayEl.getAttribute('fill') || 'transparent');
                    overlayEl.setAttribute('tabindex', '0');
                    overlayEl.dataset.behaviorIndex = String(bi);
                    overlayEl.dataset.shapeIndex = String(si);
                    // Event handlers show behavior info
                    overlayEl.addEventListener('click', (ev) => { ev.stopPropagation(); this.showBehaviorInfo(behavior, 'click', overlayEl); });
                    overlayEl.addEventListener('focus', () => this.showBehaviorInfo(behavior, 'focus', overlayEl));
                    overlayGroup.appendChild(overlayEl);

                    // Wire overlay DOM back to inventoryData if a synthetic overlay item was created
                    try {
                        const invItem = this.inventoryData.find(it => it.category === 'overlay' && it.behaviorIndex === bi && it.shapeIndex === si);
                        if (invItem) invItem.domElement = overlayEl;
                    } catch (e) { /* ignore */ }
                });
            });
            // Overlay visibility is controlled via classes on #visualization (jim-overlays-visible / jim-overlays-hidden)
            // Do not mutate overlayGroup.style.display here to avoid conflicting with class-based CSS control.
        } catch (e) { /* non-fatal overlay render errors */ }
        this.displayVisualization(svgClone);
    }

    // Ensure the overlay show/hide toggle exists inside #visualization and reflects current state
    _ensureOverlayToggle() {
        try {
            const viz = document.getElementById('visualization');
            const heading = document.getElementById('visualization-heading');
            if (!viz || !heading) return;
            const hasShapeOverlays = Array.isArray(this.jimData?.behaviors) && this.jimData.behaviors.some(b => Array.isArray(b?.target?.shapes) && b.target.shapes.length > 0);
            // Look for existing toggle anywhere near the heading (by id)
            const existing = document.getElementById('jim-overlay-toggle');
            if (!hasShapeOverlays) {
                if (existing) existing.remove();
                viz.classList.remove('jim-overlays-visible','jim-overlays-hidden');
                return;
            }
            if (!window.jimViewer) window.jimViewer = {};
            if (typeof window.jimViewer.showOverlays === 'undefined') window.jimViewer.showOverlays = true;

            const applyVizClass = () => {
                viz.classList.remove('jim-overlays-visible','jim-overlays-hidden');
                viz.classList.add(window.jimViewer.showOverlays ? 'jim-overlays-visible' : 'jim-overlays-hidden');
            };

            if (existing) {
                // Update existing toggle state and accessible labels
                existing.textContent = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
                existing.setAttribute('aria-pressed', String(!!window.jimViewer.showOverlays));
                existing.setAttribute('aria-label', 'Toggle shape overlays');
                existing.title = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
                // Rebind click handler safely by replacing node (which preserves attributes when cloned)
                const newNode = existing.cloneNode(true);
                existing.replaceWith(newNode);
                const repl = document.getElementById('jim-overlay-toggle');
                if (repl) repl.addEventListener('click', () => {
                    window.jimViewer.showOverlays = !window.jimViewer.showOverlays;
                    repl.textContent = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
                    repl.setAttribute('aria-pressed', String(!!window.jimViewer.showOverlays));
                    repl.title = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
                    applyVizClass();
                });
                applyVizClass();
                return;
            }

            const toggle = document.createElement('button');
            toggle.id = 'jim-overlay-toggle';
            toggle.className = 'btn jim-overlay-toggle';
            toggle.setAttribute('aria-pressed', String(!!window.jimViewer.showOverlays));
            toggle.setAttribute('aria-label', 'Toggle shape overlays');
            toggle.title = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
            toggle.textContent = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
            toggle.addEventListener('click', () => {
                window.jimViewer.showOverlays = !window.jimViewer.showOverlays;
                toggle.textContent = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
                toggle.setAttribute('aria-pressed', String(!!window.jimViewer.showOverlays));
                toggle.title = window.jimViewer.showOverlays ? 'Hide shape overlays' : 'Show shape overlays';
                applyVizClass();
            });
            applyVizClass();
            // Insert after the visualization heading
            if (heading.parentNode) {
                if (heading.nextSibling) heading.parentNode.insertBefore(toggle, heading.nextSibling);
                else heading.parentNode.appendChild(toggle);
            }
        } catch (e) { /* ignore failures */ }
    }

    // Show info for elements mapped by behavior (wildcard/class support)
    showElementInfoByBehavior(behavior, eventType, element) {
        // Try to find a selectorKey for this element if possible
        const selectors = this.jimData.selectors || {};
        let selectorKey = null;
        // First, try to match by selector dom (e.g., #edge-AB)
        for (const [key, sel] of Object.entries(selectors)) {
            try {
                if (element.matches(sel.dom)) {
                    selectorKey = key;
                    break;
                }
            } catch {}
        }
        // If not found, try to match by element ID to selector dom value
        if (!selectorKey && element.id) {
            for (const [key, sel] of Object.entries(selectors)) {
                if (sel.dom === `#${element.id}`) {
                    selectorKey = key;
                    break;
                }
            }
        }
        // Fallback: use behavior target.selector as a hint if no declared selectorKey found
        if (!selectorKey) selectorKey = behavior.target?.selector || null;
    // console.trace info removed

        // If selectorKey corresponds to a declared JIM selector key, show element info for that key.
        // Otherwise, this is a behavior-only target (e.g. '.number-line') — show behavior-level info.
        if (selectorKey && Object.prototype.hasOwnProperty.call(selectors, selectorKey)) {
            this.showElementInfo(selectorKey, eventType, element);
        } else {
            // Behavior-only target: surface the behavior info directly using the live cloned element
            this.showBehaviorInfo(behavior, eventType, element);
        }
    }
    // Full SVG accessibility and JIM selector validation
    validateJIMStructure() {
        const results = {
            svgInventory: [],
            errors: [],
            warnings: [],
            passed: [],
            orphanedSelectors: [],
            facetSummary: null,
            behaviorSummary: null,
            selectorSummary: null
        };
        const selectors = this.jimData?.selectors || {};
        const behaviors = this.jimData?.behaviors || [];
        const facets = this.jimData?.datasets?.[0]?.facets || {};
        // --- JIM selector validation ---
        let domValid = 0, jsonValid = 0;
        if (Object.keys(selectors).length) {
            // Check for orphaned selectors (not in DOM)
            Object.entries(selectors).forEach(([key, sel]) => {
                let el = null;
                try {
                    el = this.currentDoc.querySelector(sel.dom);
                } catch {}
                if (!el) {
                    results.orphanedSelectors.push({
                        key,
                        selector: sel.dom,
                        jsonPath: sel.json,
                        data: this.getDataFromJSONPath(sel.json)
                    });
                } else {
                    domValid++;
                }
                if (this.getDataFromJSONPath(sel.json) !== null) {
                    jsonValid++;
                }
            });
            results.selectorSummary = {
                domValid,
                jsonValid,
                total: Object.keys(selectors).length
            };
            // Only push orphanedSelectors warning to warnings, not summary lines
            if (results.orphanedSelectors.length) {
                results.warnings.push(`${results.orphanedSelectors.length} JIM selector(s) not found in SVG DOM.`);
            }
        }
        // --- Facet validation ---
        if (facets && Object.keys(facets).length) {
            // Check that all record keys in all series have a facet
            const dataset = this.jimData?.datasets?.[0];
            if (dataset?.series) {
                const allRecordKeys = new Set();
                dataset.series.forEach(s => {
                    if (Array.isArray(s.records)) {
                        s.records.forEach(r => Object.keys(r).forEach(k => allRecordKeys.add(k)));
                    }
                });
                const undocumentedKeys = [...allRecordKeys].filter(k => !facets[k]);
                results.facetSummary = {
                    missing: undocumentedKeys,
                    total: allRecordKeys.size
                };
                // Do not push facet summary lines to warnings/passed; handled in renderValidationResults
            }
        }
        // --- Behavior validation ---
        // Compute behavior mapping and warnings even when selectors are empty so overlay-only behaviors are surfaced
        if (Array.isArray(behaviors)) {
            const selectorKeys = Object.keys(selectors);
            const mapped = new Set(); // track which selector keys have behaviors
            const missing = [];
            let shapeBehaviors = 0;

            // Count shape-based behaviors
            behaviors.forEach(b => {
                if (Array.isArray(b?.target?.shapes) && b.target.shapes.length > 0) {
                    shapeBehaviors++;
                }
            });

            // Check each declared selector to see if any behavior targets it
            const svg = this.currentDoc.querySelector('svg');
            if (svg) {
                selectorKeys.forEach(key => {
                    const selectorDom = selectors[key].dom;
                    let hasMatchingBehavior = false;

                    // Get elements this selector matches
                    let selectorElements = [];
                    try {
                        selectorElements = Array.from(svg.querySelectorAll(selectorDom));
                    } catch (e) {
                        console.warn(`Invalid selector for key '${key}':`, selectorDom);
                    }

                    if (selectorElements.length === 0) {
                        // Selector doesn't match anything in DOM - will be reported elsewhere as orphaned
                        return;
                    }

                    // Check if any behavior targets these elements
                    for (let bi = 0; bi < behaviors.length && !hasMatchingBehavior; bi++) {
                        const b = behaviors[bi];
                        const targetSelector = b?.target?.selector;
                        if (!targetSelector) continue;

                        // 1) Try per-element matches() first (handles classes, wildcards, comma-lists)
                        for (let si = 0; si < selectorElements.length && !hasMatchingBehavior; si++) {
                            const selEl = selectorElements[si];
                            try {
                                if (selEl.matches(targetSelector)) {
                                    hasMatchingBehavior = true;
                                    break;
                                }
                            } catch (e) {
                                // matches() can throw for invalid selectors — ignore and fall back below
                            }
                        }
                        if (hasMatchingBehavior) break;

                        // 2) Fallback: query behavior elements and test equality/containment (ancestor/descendant)
                        let behaviorElements = [];
                        try { behaviorElements = Array.from(svg.querySelectorAll(targetSelector)); } catch (e) { behaviorElements = []; }
                        if (!behaviorElements.length) continue;

                        for (let si = 0; si < selectorElements.length && !hasMatchingBehavior; si++) {
                            const selectorEl = selectorElements[si];
                            for (let be = 0; be < behaviorElements.length && !hasMatchingBehavior; be++) {
                                const behaviorEl = behaviorElements[be];
                                if (selectorEl === behaviorEl) { hasMatchingBehavior = true; break; }
                                if (behaviorEl.contains && behaviorEl.contains(selectorEl)) { hasMatchingBehavior = true; break; }
                                if (selectorEl.contains && selectorEl.contains(behaviorEl)) { hasMatchingBehavior = true; break; }
                            }
                        }

                        // 3) If behavior selector matches multiple elements and any of those are members
                        //    of our selectorElements, treat as covered (group behavior)
                        if (!hasMatchingBehavior && behaviorElements.length > 1) {
                            try {
                                if (behaviorElements.some(beEl => selectorElements.includes(beEl))) {
                                    hasMatchingBehavior = true;
                                }
                            } catch (e) { /* ignore */ }
                        }
                    }

                    if (hasMatchingBehavior) mapped.add(key);
                    else missing.push(key);
                });
            }

            // NEW: count behaviors that target DOM elements but have no corresponding selectors[] entry
            // Note: match by DOM elements, not by exact selector string equality. This ensures
            // class-based, wildcard, and comma-joined selectors are properly recognized as
            // covering declared selectors when their targeted elements overlap.
            let behaviorsWithoutSelectors = 0;
            if (svg && Array.isArray(behaviors) && behaviors.length) {
                behaviors.forEach(b => {
                    const tgtSelector = b?.target?.selector;
                    if (!tgtSelector) return;

                    // Get elements this behavior targets (skip invalid selectors)
                    let behaviorElements = [];
                    try { behaviorElements = Array.from(svg.querySelectorAll(tgtSelector)); } catch (e) { return; }
                    if (!behaviorElements.length) return;

                    // Does ANY targeted element match a declared selectors[].dom? Use element.matches
                    // to handle classes, wildcards and comma-lists correctly.
                    const matchesDeclaredSelector = behaviorElements.some(el => {
                        try {
                            return selectorKeys.some(k => {
                                const declared = selectors[k] && selectors[k].dom;
                                if (!declared) return false;
                                try { return el.matches(declared); } catch { return false; }
                            });
                        } catch (e) { return false; }
                    });

                    if (!matchesDeclaredSelector) behaviorsWithoutSelectors++;
                });
            }

            results.behaviorSummary = {
                total: selectorKeys.length,
                mapped: mapped.size,
                missing: missing,
                shapeBehaviors: shapeBehaviors,
                behaviorCount: Array.isArray(behaviors) ? behaviors.length : 0,
                behaviorsWithoutSelectors: behaviorsWithoutSelectors
            };
        }
        // --- Add synthetic inventory items for behavior.target.shapes so they appear in Analysis panel ---
        try {
            if (Array.isArray(jim.behaviors) && jim.behaviors.length) {
                jim.behaviors.forEach((b, bi) => {
                    const shapes = Array.isArray(b?.target?.shapes) ? b.target.shapes : [];
                    shapes.forEach((s, si) => {
                        if (!s || typeof s !== 'object') return;
                        const kindKeys = Object.keys(s);
                        const kind = kindKeys.length ? kindKeys[0] : 'shape';
                        // Create a minimal synthetic inventory item for overlays
                        results.svgInventory.push({
                            category: 'overlay',
                            selector: `behavior[${bi}].shapes[${si}] (${kind})`,
                            element: kind,
                            hasJIM: true,
                            behaviorIndex: bi,
                            shapeIndex: si,
                            domElement: null // overlay DOM created later in renderVisualization
                        });
                    });
                });
            }
        } catch (e) { /* non-fatal inventory augmentation */ }
        // --- SVG Element Inventory: ALWAYS run ---
        if (this.currentDoc) {
            let svg = this.currentDoc.querySelector('svg');
            if (!svg && this.currentDoc.documentElement?.tagName?.toLowerCase() === 'svg') {
                svg = this.currentDoc.documentElement;
            }
            if (svg) {
                const jimSelectors = Object.values(selectors).map(s => s.dom);
                // Also consider behaviors' target.selector values when deciding whether
                // an element is JIM-mapped. This ensures behavior-only mappings (e.g. class
                // or group selectors) mark inventory items as having JIM mappings.
                const behaviorSelectors = (behaviors || []).map(b => b?.target?.selector).filter(Boolean);

                const hasJIMMapping = (el) => {
                    if (!el) return false;
                    try {
                        for (let i = 0; i < jimSelectors.length; i++) {
                            const sel = jimSelectors[i];
                            if (!sel) continue;
                            try { if (el.matches(sel)) return true; } catch (e) { /* ignore invalid selector */ }
                        }
                    } catch (e) { /* ignore overall */ }
                    try {
                        for (let i = 0; i < behaviorSelectors.length; i++) {
                            const sel = behaviorSelectors[i];
                            if (!sel) continue;
                            try { if (el.matches(sel)) return true; } catch (e) { /* ignore invalid selector */ }
                        }
                    } catch (e) { /* ignore overall */ }
                    return false;
                };
                // text nodes
                svg.querySelectorAll('text').forEach(el => {
                    results.svgInventory.push(this.createInventoryItem(el, hasJIMMapping(el), 'text'));
                });
                // interactive (non-text with a11y attrs OR elements that have JIM mappings)
                // Treating JIM-mapped elements as interactive helps authors find mapped datapoints
                // even when the SVG doesn't include explicit accessibility attributes.
                svg.querySelectorAll('*').forEach(el => {
                    const tag = el.tagName.toLowerCase();
                    // Skip text (handled above) and groups (handled in group pass) to avoid duplicate entries
                    if (tag === 'text' || tag === 'g') return;
                    const hasA11y = el.hasAttribute('tabindex') || el.hasAttribute('role') ||
                                    el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby') || el.hasAttribute('aria-describedby');
                    const hasJIM = hasJIMMapping(el);
                    if (hasA11y || hasJIM) {
                        results.svgInventory.push(this.createInventoryItem(el, hasJIM, 'interactive'));
                    }
                });
                // groups
                svg.querySelectorAll('g').forEach(el => {
                    if (!el.id && !(el.className && el.className.baseVal)) return;
                    results.svgInventory.push(this.createInventoryItem(el, hasJIMMapping(el), 'group'));
                });

                // Other elements: basic shapes not already categorized (catch-all)
                const categorizedSet = new Set(results.svgInventory.map(i => i.domElement));
                const shapeTags = ['polygon', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'path'];
                shapeTags.forEach(tag => {
                    svg.querySelectorAll(tag).forEach(el => {
                        if (categorizedSet.has(el)) return;
                        const hasJIM = hasJIMMapping(el);
                        results.svgInventory.push(this.createInventoryItem(el, hasJIM, 'other'));
                        categorizedSet.add(el);
                    });
                });
            }
        }
        return results;
    }
    hideInfoPanel() {
        if (this.infoPanel) {
            this.infoPanel.classList.remove('visible');
        }
        if (this.infoContent) {
            this.infoContent.innerHTML = '';
        }
        // Optionally clear the live region for SR users
        const liveRegion = document.getElementById('info-panel-live');
        if (liveRegion) {
            liveRegion.textContent = '';
        }
    }
    // Returns a default announcement string from a data object, or null if not present
    getDefaultAnnouncement(data) {
        // Use facet labels and ordering for semantic output
        const facets = this.jimData?.datasets?.[0]?.facets || {};
        // Build facet info: { key, label, role }
        const facetInfo = Object.entries(facets).map(([key, f]) => ({
            key,
            label: f.label || key,
            role: f.variableType || 'other'
        }));
        // Helper to order keys: dependent first, then independent, then others
        function orderKeys(keys) {
            const dep = facetInfo.filter(f => f.role === 'dependent').map(f => f.key);
            const indep = facetInfo.filter(f => f.role === 'independent').map(f => f.key);
            const rest = keys.filter(k => !dep.includes(k) && !indep.includes(k));
            return [...dep, ...indep, ...rest];
        }
        // Recursively flatten arrays and objects, using facet labels and ordering
        function flatten(obj, parentKey = null) {
            if (Array.isArray(obj)) {
                // Array of primitives
                if (obj.every(v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean')) {
                    return parentKey ? `${parentKey}: ${obj.join(', ')}` : obj.join(', ');
                }
                // Array of objects
                return obj.map(o => flatten(o)).filter(Boolean).join('; ');
            } else if (obj && typeof obj === 'object') {
                const keys = Object.keys(obj);
                const facetKeys = orderKeys(keys).filter(k => facetInfo.find(f => f.key === k));
                const nonFacetKeys = keys.filter(k => !facetInfo.find(f => f.key === k));
                const parts = [];
                // Facet fields first
                for (const key of facetKeys) {
                    if (!(key in obj)) continue;
                    const value = obj[key];
                    const facet = facetInfo.find(f => f.key === key);
                    const label = facet ? facet.label : key;
                    if (Array.isArray(value)) {
                        parts.push(flatten(value, label));
                    } else if (value && typeof value === 'object') {
                        const nested = flatten(value, label);
                        if (nested) parts.push(nested);
                    } else if (value !== undefined && value !== null) {
                        parts.push(`${label}: ${value}`);
                    }
                }
                // Non-facet fields, italicized
                const nonFacetParts = [];
                for (const key of nonFacetKeys) {
                    if (!(key in obj)) continue;
                    const value = obj[key];
                    const label = key;
                    if (Array.isArray(value)) {
                        nonFacetParts.push(flatten(value, label));
                    } else if (value && typeof value === 'object') {
                        const nested = flatten(value, label);
                        if (nested) nonFacetParts.push(nested);
                    } else if (value !== undefined && value !== null) {
                        nonFacetParts.push(`${label}: ${value}`);
                    }
                }
                if (nonFacetParts.length) parts.push(`<i>${nonFacetParts.join(', ')}</i>`);
                return parts.join(', ');
            } else if (obj !== undefined && obj !== null && (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean')) {
                return String(obj);
            }
            return null;
        }
        const result = flatten(data);
        return result && result.trim() ? result : null;
    }
    // Simple HTML escaper for injection-safe display
    escapeHtml(str) {
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }
    // Returns the announcement object (name/description) from a behavior, or null if not present
    getExplicitAnnouncement(behavior) {
        if (behavior && behavior.enter && behavior.enter.announcement) {
            return behavior.enter.announcement;
        }
        return null;
    }
    // Choose a human-friendly announcement string to display.
    // Preference: announcement.description, then announcement.name, then string value, then compact JSON.
    formatAnnouncement(ann) {
        if (!ann && ann !== 0) return null;
        // Plain string announcement
        if (typeof ann === 'string') {
            const s = ann.trim();
            return s ? s : null;
        }
        // Object: prefer description then name
        if (typeof ann === 'object') {
            if (ann.description && String(ann.description).trim()) return String(ann.description).trim();
            if (ann.name && String(ann.name).trim()) return String(ann.name).trim();
            // Try common alternate fields
            if (ann.label && String(ann.label).trim()) return String(ann.label).trim();
            // Fallback: compact JSON
            try { return JSON.stringify(ann); } catch (e) { return String(ann); }
        }
        // Other primitive
        return String(ann);
    }
            setupEventListeners() {
                // File input handler
                const fileInput = document.getElementById('jim-file');
                if (fileInput) {
                    fileInput.addEventListener('change', async (e) => {
                        const file = e.target.files && e.target.files[0];
                        const row = e.target.closest && e.target.closest('.file-input-row');
                        try {
                            // Use the shared helper so local file selection and autoload behave the same
                            if (file) {
                                if (typeof setCurrentFileLabel === 'function') setCurrentFileLabel(file.name || 'Local file');
                                else {
                                    const label = document.getElementById('current-file');
                                    if (label) label.textContent = file.name || 'Local file';
                                }
                                // Hide the duplicate visible filename when the native input already shows one.
                                if (row) row.classList.add('has-file');
                                const cur = document.getElementById('current-file');
                                if (cur) cur.classList.add('sr-only');
                            } else {
                                // No file selected: remove the 'has-file' state. Keep the accessible-only label hidden by default.
                                if (row) row.classList.remove('has-file');
                            }
                        } catch (e) { /* ignore */ }

                        if (!file) return;
                        const ext = file.name.split('.').pop().toLowerCase();
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            const text = ev.target.result;
                            this.handleFileLoad(text, ext);
                        };
                        reader.readAsText(file);
                    });
                }

                // Info panel close button
                const closeBtn = document.querySelector('.info-panel .close-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.hideInfoPanel());
                }
                // Delegated click/keyboard handlers for inventory and selector buttons
                document.addEventListener('click', (e) => {
                    const btn = e.target.closest && e.target.closest('.inventory-button, .selector-button');
                    if (!btn) return;
                    if (btn.classList.contains('inventory-button')) {
                        const category = btn.dataset.category;
                        const idx = Number(btn.dataset.idx);
                        if (!Number.isNaN(idx)) {
                            // Special case: group-preview elements rendered inside group behavior info
                            if (category === 'group-preview') {
                                const el = this._groupPreviewElements && this._groupPreviewElements[idx];
                                if (el) {
                                    // Inspect the actual element from the visualization
                                    this.showNonJIMElementInfo(el, 'select');
                                }
                            // Special case: shape behavior inspect buttons rendered in the Selectors panel
                            } else if (category === 'shape-behavior') {
                                const behavior = this._shapeBehaviors && this._shapeBehaviors[idx];
                                if (behavior) {
                                    this.showBehaviorInfo(behavior, 'select', null);
                                }
                            } else if (category === 'behavior-without-selector') {
                                const behavior = this._behaviorsWithoutSelectors && this._behaviorsWithoutSelectors[idx];
                                if (behavior) {
                                    this.showBehaviorInfo(behavior, 'select', null);
                                }
                            } else {
                                // Use global handler for inventory items
                                window.handleInventoryItemClick && window.handleInventoryItemClick(category, idx);
                            }
                        }
                    } else if (btn.classList.contains('selector-button')) {
                        const key = btn.dataset.key;
                        if (key) {
                            this.showElementInfo(key, 'select', null);
                        } else if (btn.dataset.selector) {
                            // Group behavior button: primary action is to open full element info
                            const sel = btn.dataset.selector;
                            if (sel) this.showGroupPrimaryAction(sel);
                        }
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (e.key !== 'Enter' && e.key !== ' ') return;
                    const active = document.activeElement;
                    if (!active) return;
                    if (active.classList && (active.classList.contains('inventory-button') || active.classList.contains('selector-button'))) {
                        e.preventDefault();
                        active.click();
                    }
                });
            }

            handleFileLoad(text, ext) {
                // Reset UI/data
                this.jimData = null;
                this.currentDoc = null;
                this.specIssues = null;
                this.inventoryData = [];
                this.detailedAnalysis = '';
                document.getElementById('metadata-summary').innerHTML = '';
                document.getElementById('visualization').innerHTML = '';
                document.getElementById('analysis-content').innerHTML = '';
                const analysisSectionEl = document.getElementById('analysis-section');
                if (analysisSectionEl) analysisSectionEl.classList.add('hidden');
                this.hideInfoPanel();

                // Parse file
                let doc;
                if (ext === 'svg') {
                    const parser = new DOMParser();
                    doc = parser.parseFromString(text, 'image/svg+xml');
                } else if (ext === 'html' || ext === 'htm') {
                    const parser = new DOMParser();
                    doc = parser.parseFromString(text, 'text/html');
                } else {
                    this.showError('Unsupported file type.');
                    return;
                }
                this.currentDoc = doc;

                // Try to find and parse JIM metadata
                let jim = null;
                let jimText = null;
                // Look for <script type="application/json+jim"> or <metadata id="jim"> or window.JIM_DATA
                if (ext === 'svg') {
                    // <script type="application/json+jim">
                    const script = doc.querySelector('script[type="application/json+jim"]');
                    if (script) jimText = script.textContent;
                    // <metadata id="jim">
                    if (!jimText) {
                        const meta = doc.querySelector('metadata#jim');
                        if (meta) jimText = meta.textContent;
                    }
                    // <metadata data-type="text/jim+json">
                    if (!jimText) {
                        const metaType = doc.querySelector('metadata[data-type="text/jim+json"]');
                        if (metaType) jimText = metaType.textContent;
                    }
                } else if (ext === 'html' || ext === 'htm') {
                    // <script type="application/json+jim">
                    const script = doc.querySelector('script[type="application/json+jim"]');
                    if (script) jimText = script.textContent;
                }
                if (jimText) {
                    console.log('[JIMViewer] Raw JIM text found:', jimText);
                    try {
                        jim = JSON.parse(jimText);
                        console.log('[JIMViewer] Parsed JIM object:', jim);
                    } catch (e) {
                        // Try to extract line/column from error message
                        let lineInfo = '';
                        let snippet = '';
                        const match = e.message.match(/at position (\d+)/);
                        if (match) {
                            const pos = parseInt(match[1], 10);
                            // Find line/column
                            const pre = jimText.slice(0, pos);
                            const line = pre.split('\n').length;
                            const col = pos - pre.lastIndexOf('\n');
                            lineInfo = ` (line ${line} column ${col})`;
                            // Show a snippet around the error
                            snippet = jimText.slice(Math.max(0, pos-40), pos+40);
                        }
                        let errorHtml = `<div class="error-box">` +
                            `<strong class="error-text"><span class="sr-only">Error: </span>${ICONS.cross} Invalid JIM JSON in file${lineInfo}</strong><br>` +
                            `<div class='muted-note' style='color:var(--status-error);'>${e.message}</div>` +
                            (snippet ? `<pre class='snippet snippet--error'>${snippet.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre>` : '') +
                            `<div class='muted-note'>Tip: Check for missing commas, brackets, or invalid array/object usage. You can copy and validate this JSON at <a href='https://jsonlint.com/' target='_blank' style='color:#2563eb;'>jsonlint.com</a>.</div>` +
                            `</div>`;
                        document.getElementById('metadata-summary').innerHTML = errorHtml;
                        this.specIssues = null;
                        this.jimData = null;
                        return;
                    }
                } else {
                    console.warn('[JIMViewer] No JIM metadata found in file.');
                    const errorHtml = `<div class="error-box">` +
                        `<strong class="error-text"><span class="sr-only">Error: </span>${ICONS.cross} No JIM metadata found in file</strong><br>` +
                        `<div class='muted-note' style='color:var(--status-error);'>JIM metadata must be in a &lt;script type="application/json+jim"&gt; or &lt;metadata data-type="text/jim+json"&gt; block.</div>` +
                        `<div class='muted-note'>Tip: Check your SVG for a valid JIM metadata block.</div>` +
                        `</div>`;
                    document.getElementById('metadata-summary').innerHTML = errorHtml;
                    this.specIssues = null;
                    this.jimData = null;
                }

                // Preflight and normalize JIM if present
                if (jim && Object.keys(jim).length > 0) {
                    const preflight = preflightJIM(jim, doc);
                    this.specIssues = {
                        errors: preflight.errors,
                        warnings: preflight.warnings,
                        fixes: preflight.fixesApplied
                    };
                    this.jimData = preflight.normalizedJim;
                    console.log('[JIMViewer] JIM data after preflight:', this.jimData);
                } else if (jim && Object.keys(jim).length === 0) {
                    console.warn('[JIMViewer] JIM metadata is present but empty.');
                    this.specIssues = null;
                    this.jimData = null;
                } else {
                    this.specIssues = null;
                    this.jimData = null;
                }

                // Render summary and visualization
                this.displayMetadataSummary();
                if (this.currentDoc && (this.jimData || this.currentDoc.querySelector('svg'))) {
                    this.renderVisualization();
                }
            }
            displayMetadataSummary() {
                // Render selector list panel if JIM metadata is present
                var selectorPanel = document.getElementById('selector-list-panel');
                // Show selector panel if there are explicit selectors OR if there are shape behaviors
                const hasSelectors = !!(this.jimData && this.jimData.selectors && Object.keys(this.jimData.selectors).length);
                const hasShapeBehaviors = !!((this.jimData && Array.isArray(this.jimData.behaviors) && this.jimData.behaviors.some(b => Array.isArray(b?.target?.shapes) && b.target.shapes.length > 0)));
                if (hasSelectors || hasShapeBehaviors) {
                    var selectorKeys = Object.keys(this.jimData.selectors);
                    var behaviors = this.jimData.behaviors || [];
                    var selectorPanelHtml = "<div class='selector-panel'>";
                    selectorPanelHtml += "<h2 class='panel__heading'>Selectors</h2>";
                    
                    var svg = this.currentDoc.querySelector('svg');
                    // Track group behaviors
                    var groupBehaviors = [];
                    for (var j = 0; j < behaviors.length; j++) {
                        var tgtSelector = behaviors[j].target && behaviors[j].target.selector;
                        if (tgtSelector) {
                            var B = [];
                            try { B = Array.from(svg.querySelectorAll(tgtSelector)); } catch (e) {}
                            if (B.length > 1) {
                                groupBehaviors.push({ selector: tgtSelector, elements: B });
                            }
                        }
                    }
                    // Console-check: warn if a group behavior selector does not have a corresponding
                    // `selectors` entry. Be tolerant: if the group selector is a comma-joined
                    // list (e.g. many #datapoint-... ids) but individual selectors[].dom entries
                    // cover those member elements, consider the group covered and do not warn.
                    try {
                        if (groupBehaviors.length && this.jimData && this.jimData.selectors) {
                            var declaredSelectors = Object.values(this.jimData.selectors).map(function(s){ return s && s.dom; }).filter(Boolean);
                            groupBehaviors.forEach(function(gb){
                                var covered = false;
                                for (var di = 0; di < declaredSelectors.length; di++) {
                                    var ds = declaredSelectors[di];
                                    if (!ds) continue;
                                    // Exact match (covers simple cases)
                                    if (ds === gb.selector) { covered = true; break; }
                                    // If any member element matches an existing declared selector,
                                    // treat the group as covered (handles comma-joined group selectors)
                                    try {
                                        if (gb.elements.some(function(el){ try { return el.matches(ds); } catch(e){ return false; } })) { covered = true; break; }
                                    } catch (e) { /* ignore per-element match failures */ }
                                }
                                if (!covered) {
                                    console.warn("[JIMViewer] Group behavior selector '" + gb.selector + "' has no matching JIM selector entry in selectors[].dom. Consider adding a selector for the group so it appears in the selector report.");
                                }
                            });
                        }
                    } catch (e) { /* non-fatal console check */ }
                    // Build a list of visible selectors (those that match at least one SVG element),
                    // annotate them with mapping state, then sort: mapped first, group-mapped second,
                    // unmapped last. Within each bucket sort alphabetically by selector key.
                    // FIRST: detect behaviors that target DOM elements directly but have no matching
                    // declared JIM selector entry. We'll surface these in the Selectors panel so
                    // authors know to add a selector if desired.
                    var svg = this.currentDoc.querySelector('svg');
                    var behaviorsWithoutSelectors = [];
                    for (var bj = 0; bj < behaviors.length; bj++) {
                        var tgtSelector = behaviors[bj].target && behaviors[bj].target.selector;
                        if (!tgtSelector) continue;

                        // Get elements this behavior targets (skip invalid selectors)
                        var B = [];
                        try { B = Array.from(svg.querySelectorAll(tgtSelector)); } catch (e) { continue; }
                        if (!B.length) continue;

                        // Does ANY targeted element match a declared selectors[].dom? Use element.matches
                        // to ensure class/wildcard/comma selectors are handled correctly.
                        var matchesDeclaredSelector = false;
                        for (var bi = 0; bi < B.length && !matchesDeclaredSelector; bi++) {
                            var el = B[bi];
                            for (var dk = 0; dk < selectorKeys.length && !matchesDeclaredSelector; dk++) {
                                var declaredKey = selectorKeys[dk];
                                var declaredDom = this.jimData.selectors[declaredKey].dom;
                                if (!declaredDom) continue;
                                try {
                                    if (el.matches(declaredDom)) { matchesDeclaredSelector = true; break; }
                                } catch (e) { /* per-declared selector match failure ignored */ }
                            }
                        }

                        if (!matchesDeclaredSelector) {
                            behaviorsWithoutSelectors.push({ selector: tgtSelector, elementCount: B.length, behavior: behaviors[bj] });
                        }
                    }

                    var visibleSelectors = [];
                    for (var k = 0; k < selectorKeys.length; k++) {
                        var key = selectorKeys[k];
                        var dom = this.jimData.selectors[key].dom;
                        var hasBehavior = false;
                        var isGroupMapped = false;
                        // Get elements this selector matches
                        var selectorElements = [];
                        try { selectorElements = Array.from(svg.querySelectorAll(dom)); } catch (e) { console.warn(`Invalid selector for key '${key}':`, dom); }
                        // Only include selectors that match at least one SVG element
                        if (!selectorElements.length) continue;

                        // Check each behavior to see if it targets these elements
                        for (var j = 0; j < behaviors.length; j++) {
                            var tgtSelector = behaviors[j].target && behaviors[j].target.selector;
                            if (!tgtSelector) continue;

                            // Get elements the behavior targets
                            var behaviorElements = [];
                            try { behaviorElements = Array.from(svg.querySelectorAll(tgtSelector)); } catch (e) { continue; }

                            // Check for relationship: only DIRECT match or containment (ancestor/descendant) mark as mapped.
                            var relationFound = false;
                            var relationKind = null;
                            for (var si = 0; si < selectorElements.length && !relationFound; si++) {
                                var selectorEl = selectorElements[si];
                                for (var bi = 0; bi < behaviorElements.length && !relationFound; bi++) {
                                    var behaviorEl = behaviorElements[bi];
                                    if (selectorEl === behaviorEl) { relationFound = true; relationKind = 'direct'; break; }
                                    if (behaviorEl.contains && behaviorEl.contains(selectorEl)) { relationFound = true; relationKind = 'descendant'; break; }
                                    if (selectorEl.contains && selectorEl.contains(behaviorEl)) { relationFound = true; relationKind = 'ancestor'; break; }
                                    // NOTE: intentionally do NOT consider siblings or common ancestors here.
                                }
                            }

                            if (relationFound) {
                                if (relationKind === 'direct' || relationKind === 'descendant' || relationKind === 'ancestor') {
                                    hasBehavior = true;
                                    break;
                                }
                            }
                        }

                        visibleSelectors.push({ key: key, dom: dom, hasBehavior: hasBehavior, isGroupMapped: isGroupMapped });
                    }

                    // Sorting helper: rank mapped=0, group=1, unmapped=2
                    function selRank(s) { return s.hasBehavior ? 0 : (s.isGroupMapped ? 1 : 2); }
                    visibleSelectors.sort(function(a, b) {
                        var ra = selRank(a), rb = selRank(b);
                        if (ra !== rb) return ra - rb;
                        // Natural (numeric-aware) alphabetical fallback so 'datapoint2' sorts before 'datapoint10'
                        return a.key.localeCompare(b.key, undefined, { numeric: true, sensitivity: 'base' });
                    });

                    // Partition into buckets for clearer traversal
                    var mapped = visibleSelectors.filter(function(s){ return s.hasBehavior; });
                    var groupMapped = visibleSelectors.filter(function(s){ return !s.hasBehavior && s.isGroupMapped; });
                    var unmapped = visibleSelectors.filter(function(s){ return !s.hasBehavior && !s.isGroupMapped; });

                    // Helper to render a bucket with a heading
                    function renderBucket(title, items, extraClass) {
                        if (!items || !items.length) return '';
                        var out = `<h3 class='panel__heading'>${title} (${items.length})</h3>`;
                        out += "<div class='selector-row'>";
                        for (var ii = 0; ii < items.length; ii++) {
                            var sel = items[ii];
                            var key = sel.key;
                            var hasBehavior = sel.hasBehavior;
                            var isGroupMapped = sel.isGroupMapped;
                            var cls = 'btn selector-button';
                            if (hasBehavior) cls += ' btn--selector--mapped';
                            else if (isGroupMapped) cls += ' btn--selector--group';
                            else cls += ' btn--selector';
                            var icon = hasBehavior ? "<span class='sr-only'>Mapped: </span>" + ICONS.check : (isGroupMapped ? "<span class='sr-only'>Group: </span>" + ICONS.group : "");
                            var ariaState = hasBehavior ? ', mapped' : (isGroupMapped ? ', group mapped' : ', not mapped');
                            var ariaLabel = `Selector ${key}${ariaState}`;
                            out += `<button class='${cls} selector-button' data-key='${key}' aria-label='${ariaLabel}'>${icon}${key}</button>`;
                        }
                        out += "</div>";
                        return out;
                    }

                    selectorPanelHtml += renderBucket('Mapped Selectors', mapped);
                    selectorPanelHtml += renderBucket('Group-mapped Selectors', groupMapped);
                    selectorPanelHtml += renderBucket('Unmapped Selectors', unmapped);

                    // Behaviors Without JIM Selectors section (BEFORE group behaviors) - INTERACTIVE
                    if (behaviorsWithoutSelectors.length) {
                        selectorPanelHtml += `<div style='margin-top:16px;'><h3 class='panel__heading'>Behaviors Without JIM Selectors (${behaviorsWithoutSelectors.length})</h3>`;
                        selectorPanelHtml += `<div class='muted-note'>These behaviors target DOM elements directly but have no corresponding JIM selector entries. Click to inspect:</div>`;

                        // Store behavior references for the delegated handler
                        this._behaviorsWithoutSelectors = [];

                        behaviorsWithoutSelectors.forEach(function(b) {
                            const btnIdx = this._behaviorsWithoutSelectors.length;
                            this._behaviorsWithoutSelectors.push(b.behavior);

                            selectorPanelHtml += `<div class='panel panel--warning' style='padding:8px;margin:8px 0;display:inline-block;'>`;
                            selectorPanelHtml += `<button class='inventory-button' data-category='behavior-without-selector' data-idx='${btnIdx}' aria-label='Inspect behavior targeting ${b.selector}' style='font-weight:600;margin-right:8px;'>Inspect</button>`;
                            selectorPanelHtml += `<strong>Selector:</strong> <code>${b.selector}</code><br>`;
                            selectorPanelHtml += `<span class='muted'>Matches ${b.elementCount} element(s) in DOM</span>`;
                            selectorPanelHtml += `</div>`;
                        }.bind(this));

                        selectorPanelHtml += `</div>`;
                    }

                    // Add group behaviors section
                    if (groupBehaviors.length) {
                        // Build interactive group behavior controls: header button + member preview buttons
                        selectorPanelHtml += `<div style='margin-top:16px;'><h3 class='panel__heading'>Group Behaviors (${groupBehaviors.length})</h3><div class='group-behaviors-list' aria-hidden='false'>`;
                        // We'll collect referenced elements so the delegated handler can inspect them
                        var _groupPreviewEls = [];
                        var _gpIndex = 0;
                        groupBehaviors.forEach(gb => {
                            // Outer wrapper uses panel styling for emphasis
                            selectorPanelHtml += `<div class='panel panel--warning group-behavior'>`;
                            // Layout row: selector button + match count
                            selectorPanelHtml += `<div class='group-behavior-row'>`;
                            // Compact primary button; put long selector text in a wrapping element so it can wrap
                            selectorPanelHtml += `<button class='btn selector-button btn--selector--group' data-selector='${gb.selector}' aria-label='Activate group: ${gb.selector}' style='font-weight:600;'>Open group</button>`;
                            selectorPanelHtml += `<div class='group-selector-text' aria-hidden='false'>${gb.selector}</div>`;
                            selectorPanelHtml += `<span style='font-size:12px;margin-left:6px;' aria-hidden='true'>(matches ${gb.elements.length} elements)</span>`;
                            selectorPanelHtml += `</div>`;

                            // Register all group members into the preview array first
                            const startIndex = _gpIndex; // first index for this group's members
                            for (let ei = 0; ei < gb.elements.length; ei++) {
                                _groupPreviewEls.push(gb.elements[ei]);
                                _gpIndex++;
                            }

                            // Render member previews in a single chips container (wraps across lines)
                            selectorPanelHtml += `<div class='group-preview-row'>`;
                            selectorPanelHtml += `<div class='group-preview-chips' role='list' aria-label='Group members preview'>`;
                            for (let vi = 0; vi < gb.elements.length; vi++) {
                                const el = gb.elements[vi];
                                const label = el.id ? `#${el.id}` : (el.classList && el.classList.length) ? '.' + Array.from(el.classList).join('.') : el.tagName;
                                const dataIdx = startIndex + vi; // actual index into _groupPreviewEls
                                // Per ARIA, role=listitem should be on a container element (not on a button).
                                selectorPanelHtml += `<div role='listitem' class='group-preview-item' style='margin-right:6px;margin-bottom:6px;'><button class='inventory-button badge badge--muted' data-category='group-preview' data-idx='${dataIdx}' aria-label='SVG element ${label}'>${label}</button></div>`;
                            }
                            selectorPanelHtml += `</div>`;
                            selectorPanelHtml += `</div>`;

                            selectorPanelHtml += `</div>`;
                        });
                        selectorPanelHtml += `</div></div>`;
                        // Attach the preview element references to the instance for the delegated click handler
                        try { this._groupPreviewElements = _groupPreviewEls; } catch (e) { /* ignore if not in class context */ }
                    }

                    // Shape Behaviors subsection: behaviors that define target.shapes
                    try {
                        const shapeBehaviors = (this.jimData.behaviors || []).map((b, idx) => ({ b, idx })).filter(x => Array.isArray(x.b?.target?.shapes) && x.b.target.shapes.length > 0);
                        if (shapeBehaviors.length) {
                            selectorPanelHtml += `<div style='margin-top:16px;'><h3 class='panel__heading'>Shape Behaviors (${shapeBehaviors.length})</h3><div class='group-behaviors-list' aria-hidden='false'>`;
                            // store behavior refs for delegated handler
                            this._shapeBehaviors = [];
                            shapeBehaviors.forEach(sb => {
                                const b = sb.b;
                                const bi = sb.idx;
                                // Simple label: always use 'Behavior N' to keep list compact and predictable
                                const btnLabel = `Behavior ${bi}`;
                                selectorPanelHtml += `<div class='panel group-behavior' style='padding:8px;margin-bottom:8px;display:inline-block;'><button class='inventory-button' data-category='shape-behavior' data-idx='${this._shapeBehaviors.length}' aria-label='Open ${this.escapeHtml(btnLabel)}' style='font-weight:600;margin-right:8px;'>${this.escapeHtml(btnLabel)}</button></div>`;
                                this._shapeBehaviors.push(b);
                            });
                            selectorPanelHtml += `</div></div>`;
                        }
                    } catch (e) { /* ignore shape-behavior UI failures */ }

                    selectorPanelHtml += "</div>";
                    selectorPanel.innerHTML = selectorPanelHtml;
                    selectorPanel.classList.remove('hidden');
                } else {
                    selectorPanel.innerHTML = '';
                    selectorPanel.classList.add('hidden');
                }
                console.log('displayMetadataSummary called, JIM data present:', !!this.jimData);
                const summary = document.getElementById('metadata-summary');
                // Show spec compliance box if preflight found errors/warnings
                                let specBox = '';
                                                if (this.specIssues) {
                                                                    if (this.specIssues.errors.length || this.specIssues.warnings.length) {
                                                                        const variant = this.specIssues.errors.length ? 'error' : 'warning';
                                                                        const headingColor = this.specIssues.errors.length ? 'var(--status-error)' : 'var(--status-warning)';
                                                                        specBox = `<div class="spec-box spec-box--${variant}">
                                                                            <strong class="spec-box-heading">Spec compliance</strong>
                                                                            <ul class="spec-box-list">
                                                ${this.specIssues.errors.map(e=>`<li class="status-error-line"><span class="sr-only">Error: </span>${ICONS.cross} ${e}</li>`).join('')}
                                                ${this.specIssues.warnings.map(w=>`<li class="status-warning-line"><span class="sr-only">Warning: </span>${ICONS.warn} ${w}</li>`).join('')}
                                                                            </ul>
                                                                            ${this.specIssues.fixes.length ? `<div class="spec-box-fixes">Normalizations: ${this.specIssues.fixes.join(', ')}</div>` : ''}
                                                                        </div>`;
                                                                    } else {
                                                                        // No errors or warnings: show green success box
                                                                        specBox = `<div class="spec-box spec-box--success">
                                                                            <strong class="spec-box-heading"><span class="sr-only">Success: </span>${ICONS.check} No JIM issues found</strong>
                                                                        </div>`;
                                                                    }
                                                                }

                if (!this.jimData) {
                    // SVG-only mode: build an inventory that includes basic shapes (other)
                    console.log('SVG-only mode: building inventory via renderSVGInventoryOnly');
                    const html = `
                        ${specBox}
                        <div class="metadata-summary">
                            <h3>Document Information</h3>
                            <div class="metadata-item">
                                <span class="key">Mode:</span>
                                <span class="value">SVG Accessibility Inspector</span>
                            </div>
                            <div class="metadata-item">
                                <span class="key">JIM Metadata:</span>
                                <span class="value warning-text">Not present</span>
                            </div>
                            <div class="metadata-item">
                                <span class="key">Features:</span>
                                <span class="value">Element inspection, accessibility audit, style analysis</span>
                            </div>
                            <h3 class="section-heading">SVG Accessibility Audit</h3>
                            ${this.renderAccessibilityAudit()}
                        </div>
                    `;
                    summary.innerHTML = html;
                    // Ensure the overlay toggle reflects current state and is rendered in the page
                    try { if (typeof this._ensureOverlayToggle === 'function') this._ensureOverlayToggle(); } catch (e) { /* ignore */ }
                    // renderSVGInventoryOnly builds inventoryData and returns HTML that includes 'other' shapes
                    this.detailedAnalysis = this.renderSVGInventoryOnly();
                    this.updateDetailedAnalysis();
                    return;
                }

                const dataset = this.jimData.datasets?.[0];
                // Always run validation, even if no dataset
                const validation = this.validateJIMStructure();
                this.inventoryData = validation.svgInventory;
                console.log('JIM mode validation completed, inventory items:', this.inventoryData?.length);
                let html = '';
                html = `
                    ${specBox}
                    <div class="metadata-summary">
                        <h3>Document Metadata</h3>
                        ${dataset ? `
                            <div class="metadata-item">
                                <span class="key">Title:</span>
                                <span class="value">${dataset.title || 'Untitled'}</span>
                            </div>
                            <div class="metadata-item">
                                <span class="key">Type:</span>
                                <span class="value">${dataset.representation?.chartType || 'Unknown'}</span>
                            </div>
                            <div class="metadata-item">
                                <span class="key">Series:</span>
                                <span class="value">${dataset.series?.length || 0}</span>
                            </div>
                        ` : `
                            <div class="metadata-item">
                                <span class="key">Datasets:</span>
                                <span class="value warning-text">Not present</span>
                            </div>
                        `}
                        <div class="metadata-item">
                            <span class="key">JIM Version:</span>
                            <span class="value">${this.jimData.version?.jim || 'Unknown'}</span>
                        </div>
                        <h3 class="section-heading">JIM Validation</h3>
                        ${this.renderValidationResults(validation)}
                    </div>
                `;
                summary.innerHTML = html;
                // Ensure the overlay toggle reflects current state and is rendered below the visualization heading
                try { if (typeof this._ensureOverlayToggle === 'function') this._ensureOverlayToggle(); } catch (e) { /* ignore */ }
                this.detailedAnalysis = this.renderInventoryList(validation);
                this.updateDetailedAnalysis();
            }
        showNonJIMElementInfo(element, eventType) {
            if (!element) return;
            let html = '';
            const tag = element.tagName;
            const id = element.id ? `#${element.id}` : '';
            const classes = element.classList.length ? '.' + [...element.classList].join('.') : '';
            html += `<div><strong>SVG Element:</strong> <code>${tag}${id}${classes}</code></div>`;
            html += `<div><strong>Event:</strong> <code>${eventType}</code></div>`;

            // Accessibility attributes section
            html += '<h4 class="spec-heading">Accessibility Attributes</h4>';
            html += `<div><strong>aria-label:</strong> ${element.getAttribute('aria-label') || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>aria-labelledby:</strong> ${element.getAttribute('aria-labelledby') || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>aria-describedby:</strong> ${element.getAttribute('aria-describedby') || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>role:</strong> ${element.getAttribute('role') || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>tabindex:</strong> ${element.getAttribute('tabindex') !== null ? element.getAttribute('tabindex') : '<span class="muted">Not present</span>'}</div>`;

            let titleText = null;
            let descText = null;
            const titleEl = element.querySelector('title');
            const titleAttr = element.getAttribute('title');
            titleText = titleEl ? titleEl.textContent : titleAttr;
            const descEl = element.querySelector('desc');
            descText = descEl ? descEl.textContent : null;
            html += `<div><strong>&lt;title&gt;:</strong> ${titleText || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>&lt;desc&gt;:</strong> ${descText || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>aria-hidden:</strong> ${element.getAttribute('aria-hidden') || '<span class="muted">Not present</span>'}</div>`;
            html += `<div><strong>aria-live:</strong> ${element.getAttribute('aria-live') || '<span class="muted">Not present</span>'}</div>`;

            // Computed styles section
            if (window.getComputedStyle) {
                const computed = window.getComputedStyle(element);
                html += '<h4 class="spec-heading">Computed Styles</h4>';

                // Small helper: parse rgb/#hex into [r,g,b]
                function parseRgbLocal(str) {
                    if (!str) return null;
                    str = String(str).trim();
                    let m;
                    if (str.startsWith('rgb')) {
                        m = str.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                        if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
                    }
                    if (str[0] === '#') {
                        const hex = str.slice(1);
                        if (hex.length === 3) return [parseInt(hex[0]+hex[0],16), parseInt(hex[1]+hex[1],16), parseInt(hex[2]+hex[2],16)];
                        if (hex.length === 6) return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
                    }
                    return null;
                }

                function relLumLocal([r,g,b]){
                    const srgb = [r,g,b].map(v => v/255).map(c => c <= 0.03928 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4));
                    return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
                }

                function contrastLocal(a,b){ const L1 = relLumLocal(a); const L2 = relLumLocal(b); const light = Math.max(L1,L2); const dark = Math.min(L1,L2); return (light + 0.05) / (dark + 0.05); }

                function chooseBlackOrWhiteFor(colorStr) {
                    const rgb = parseRgbLocal(colorStr);
                    if (!rgb) return '#ffffff'; // default to white when unknown
                    const whiteContrast = contrastLocal(rgb, [255,255,255]);
                    const blackContrast = contrastLocal(rgb, [0,0,0]);
                    return (whiteContrast >= blackContrast) ? '#ffffff' : '#000000';
                }

                // Render fill + stroke with deterministic background (white or black)
                const fillStr = computed.fill || 'none';
                const strokeStr = computed.stroke || 'none';
                const fillBg = chooseBlackOrWhiteFor(fillStr);
                const strokeBg = chooseBlackOrWhiteFor(strokeStr);

                html += `<div><strong>fill:</strong> <span class="computed-dot-wrap" style="background:${fillBg};"><span aria-hidden="true" class="computed-dot-swatch" style="background:${fillStr};"></span></span> ${fillStr}</div>`;
                html += `<div><strong>stroke:</strong> <span class="computed-dot-wrap" style="background:${strokeBg};"><span aria-hidden="true" class="computed-dot-swatch" style="background:${strokeStr};"></span></span> ${strokeStr}</div>`;
                html += `<div><strong>stroke-width:</strong> ${computed.strokeWidth}</div>`;
                html += `<div><strong>opacity:</strong> ${computed.opacity}</div>`;
                html += `<div><strong>display:</strong> ${computed.display}</div>`;
                html += `<div><strong>visibility:</strong> ${computed.visibility}</div>`;
                html += `<div><strong>cursor:</strong> ${computed.cursor}</div>`;
                if (element.tagName.toLowerCase() === 'text') {
                    html += `<div><strong>font-size:</strong> ${computed.fontSize}</div>`;
                    html += `<div><strong>font-family:</strong> ${computed.fontFamily}</div>`;
                    html += `<div><strong>font-weight:</strong> ${computed.fontWeight}</div>`;
                    const textContent = element.textContent.trim();
                    if (textContent) {
                        html += `<div class="inline-text"><strong>Text Content:</strong> \"${textContent}\"</div>`;
                    }
                }
            }

            html += `<div class="nojim-note">No JIM selector defined for this element.</div>`;
            this.infoContent.innerHTML = html;
            try { if (window.enhanceComputedDots) window.enhanceComputedDots(this.infoContent); } catch (e) { /* ignore */ }
            this.infoPanel.classList.add('visible');
            // Update the live region for SR users after the panel is visible (one-frame delay)
            const liveRegion = document.getElementById('info-panel-live');
            if (liveRegion) {
                let label = `Element info panel opened for SVG element ${tag}${id}`;
                liveRegion.textContent = '';
                requestAnimationFrame(() => {
                    liveRegion.textContent = label;
                });
            }
        }

        // Show a summary/info panel for a group behavior selector (lists member elements)
        showGroupBehaviorInfo(selector) {
            if (!selector) return;
            const svg = this.currentDoc && (this.currentDoc.querySelector('svg') || (this.currentDoc.documentElement && this.currentDoc.documentElement.tagName.toLowerCase() === 'svg' ? this.currentDoc.documentElement : null));
            if (!svg) return;

            let members = [];
            try {
                members = Array.from(svg.querySelectorAll(selector));
            } catch (e) {
                members = [];
            }
            // Collect any JIM behaviors that target this selector so we can show behavior-level info
            const behaviors = this.jimData?.behaviors ? (this.jimData.behaviors.filter(b => b?.target?.selector === selector)) : [];

            let html = `<div><strong>Group Selector:</strong> <code>${selector}</code></div>`;

            // If behaviors exist for this selector, render their announcements and a full JSON view
            if (behaviors.length) {
                const matchLabel = behaviors.length === 1 ? '1 behavior' : `${behaviors.length} behaviors`;
                html += `<div style='margin-top:8px; margin-bottom:8px;'><strong>Behavior(s):</strong> ${matchLabel}</div>`;
                // Show any explicit announcements (enter) for the group behavior
                const explicitAnns = behaviors.map(b => b.enter?.announcement).filter(Boolean);
                if (explicitAnns.length) {
                    explicitAnns.forEach((ann, i) => {
                        // Prefer human-friendly fields: description then name, fallback to serialized keys
                        let desc = '';
                        if (typeof ann === 'string') {
                            desc = ann;
                        } else if (ann && typeof ann === 'object') {
                            if (ann.description && String(ann.description).trim()) desc = ann.description;
                            else if (ann.name && String(ann.name).trim()) desc = ann.name;
                            else {
                                // Build a compact summary from known fields if available
                                const parts = [];
                                if (ann.name) parts.push(`Name: ${ann.name}`);
                                if (ann.description) parts.push(`Description: ${ann.description}`);
                                if (ann.hint) parts.push(`Hint: ${ann.hint}`);
                                desc = parts.length ? parts.join(' — ') : JSON.stringify(ann);
                            }
                        } else {
                            desc = String(ann);
                        }
                        // Use the same label as element-level panels: 'Explicit Announcement:'
                        const label = explicitAnns.length === 1 ? 'Explicit Announcement:' : `Explicit Announcement ${i+1} of ${explicitAnns.length}:`;
                        html += `<div class='announcement announcement-success' style='margin-top:8px;'><strong>${this.escapeHtml(label)}</strong><br><code>${this.escapeHtml(String(desc))}</code></div>`;
                    });
                }
                // Provide a toggle to view full behavior JSON for debugging/inspection
                const detailsOpen = behaviors.length === 1 ? ' open' : '';
                html += `<details${detailsOpen} class="details--spaced"><summary class="details-summary">Show/Hide Behavior JSON</summary><pre class="pre-meta meta-text">${JSON.stringify(behaviors, null, 2)}</pre></details>`;
                html += `<div style='margin-top:8px; margin-bottom:8px;'><strong>Members:</strong></div>`;
            } else {
                html += `<div style='margin-top:8px; margin-bottom:8px;'><strong>Members:</strong></div>`;
            }

            // Note: element-specific attributes (aria-label, computed styles) are available by opening member details.
            if (!members.length) {
                html += `<div class='muted-note'>No matching elements found in the visualization.</div>`;
            } else {
                html += `<div class='wrap-chips'>`;
                // Ensure we can inspect each member by making buttons that map back to real elements
                // Reset the preview elements on each open to avoid array growth across repeated opens
                this._groupPreviewElements = [];
                members.forEach((el, i) => {
                    const label = el.id ? `#${el.id}` : (el.classList && el.classList.length) ? '.' + Array.from(el.classList).join('.') : el.tagName;
                    // store reference and render a button that the delegated handler will pick up
                    const idx = this._groupPreviewElements.push(el) - 1;
                    html += `<button class='inventory-button badge badge--muted' data-category='group-preview' data-idx='${idx}' aria-label='SVG element ${label}' style='margin-right:6px;margin-bottom:6px;'>${label}</button>`;
                });
                html += `</div>`;
            }

            this.infoContent.innerHTML = html;
            try { if (window.enhanceComputedDots) window.enhanceComputedDots(this.infoContent); } catch (e) { /* ignore */ }
            this.infoPanel.classList.add('visible');

            // Update live region
            const liveRegion = document.getElementById('info-panel-live');
            if (liveRegion) {
                const label = `Group info panel opened for selector ${selector}, ${members.length} members`;
                liveRegion.textContent = '';
                requestAnimationFrame(() => { liveRegion.textContent = label; });
            }
        }

        // Show a panel for a single behavior (used by overlays)
        showBehaviorInfo(behavior, eventType, overlayEl) {
            if (!behavior) return;
            let html = '';
            // Render a minimal header: 'Behavior N' (index) for clarity and consistency with the selectors list
            const bi = (this.jimData && Array.isArray(this.jimData.behaviors)) ? this.jimData.behaviors.indexOf(behavior) : -1;
            const headerLabel = bi >= 0 ? `Behavior ${bi}` : 'Behavior';
            html += `<div><strong>Behavior</strong> <code>${this.escapeHtml(headerLabel)}</code></div>`;
            html += `<div><strong>Event:</strong> <code>${eventType}</code></div>`;
            if (behavior.target) {
                const tgt = behavior.target;
                if (tgt.selector) html += `<div><strong>Selector:</strong> <code>${this.escapeHtml(String(tgt.selector))}</code></div>`;
                else if (tgt.shapes) html += `<div><strong>Shapes:</strong> <code>${tgt.shapes.length} shape(s)</code></div>`;
            }
            // Explicit announcement (show name then description if present)
            const explicit = this.getExplicitAnnouncement(behavior);
            if (explicit) {
                // If it's a primitive string, show it as the name line
                if (typeof explicit === 'string') {
                    html += `<div class="announcement announcement-success"><strong>Explicit Announcement</strong><br>${this.escapeHtml(explicit)}</div>`;
                } else if (typeof explicit === 'object') {
                    const name = explicit.name ? String(explicit.name).trim() : null;
                    const desc = explicit.description ? String(explicit.description).trim() : null;
                    if (name || desc) {
                        html += `<div class="announcement announcement-success"><strong>Explicit Announcement</strong><br>`;
                        if (name) html += `${this.escapeHtml(name)}`;
                        if (desc) html += `<div class="muted-note" style="margin-top:6px">${this.escapeHtml(desc)}</div>`;
                        html += `</div>`;
                    }
                }
            }
            // Default announcement from JSON if available
            let defaultAnn = null;
            try {
                const jsonPath = behavior.target?.json;
                if (jsonPath) {
                    const data = this.getDataFromJSONPath(jsonPath);
                    defaultAnn = data ? this.getDefaultAnnouncement(data) : null;
                }
            } catch (e) { /* ignore */ }
            if (defaultAnn) html += `<div class="announcement announcement-note"><strong>Default Announcement</strong><br>${this.escapeHtml(defaultAnn)}</div>`;

            html += `<details open class="details--spaced"><summary class="details-summary">Behavior JSON</summary><pre class="pre-meta meta-text">${this.escapeHtml(JSON.stringify(behavior, null, 2))}</pre></details>`;

            this.infoContent.innerHTML = html;
            this.infoPanel.classList.add('visible');
            const liveRegion = document.getElementById('info-panel-live');
            if (liveRegion) {
                liveRegion.textContent = '';
                requestAnimationFrame(() => { liveRegion.textContent = `Behavior info opened (${eventType})`; });
            }
        }

        // Primary action for a group selector: open full element info for the first matched member
        showGroupPrimaryAction(selector) {
            if (!selector) return;
            const svg = this.currentDoc && (this.currentDoc.querySelector('svg') || (this.currentDoc.documentElement && this.currentDoc.documentElement.tagName.toLowerCase() === 'svg' ? this.currentDoc.documentElement : null));
            if (!svg) return;

            let members = [];
            try {
                members = Array.from(svg.querySelectorAll(selector));
            } catch (e) {
                members = [];
            }

            if (!members.length) {
                // Fall back to showing a group summary if no members
                this.showGroupBehaviorInfo(selector);
                return;
            }

            // If there are JIM behaviors that target this selector, show the behavior-level info first
            const behaviors = this.jimData?.behaviors ? (this.jimData.behaviors.filter(b => b?.target?.selector === selector)) : [];
            if (behaviors.length) {
                // Show the behavior panel (includes members and announcements)
                this.showGroupBehaviorInfo(selector);
                return;
            }

            // Prefer showing full JIM element info if the first member matches a JIM selector key
            const selectors = this.jimData?.selectors || {};
            let first = members[0];
            let selectorKey = null;
            for (const [key, sel] of Object.entries(selectors)) {
                try {
                    if (first.matches(sel.dom)) { selectorKey = key; break; }
                } catch(_) {}
            }

            if (selectorKey) {
                // Show JIM-based element info; find corresponding element in visualization
                this.showElementInfo(selectorKey, 'select', first);
            } else {
                // Fallback: show the non-JIM element info directly
                this.showNonJIMElementInfo(first, 'select');
            }
        }
        updateDetailedAnalysis() {
            const section = document.getElementById('analysis-section');
            const content = document.getElementById('analysis-content');
            content.innerHTML = this.detailedAnalysis || '<div class="muted-italic">No inventory available.</div>';
            section.classList.remove('hidden');
        }
        renderValidationSummary(validation) {
            let html = '';
            validation.errors.forEach(err => { html += `<div class="status-error-line"><span class="sr-only">Error: </span>${ICONS.cross} ${err}</div>`; });
            validation.warnings.forEach(w => { html += `<div class="status-warning-line"><span class="sr-only">Warning: </span>${ICONS.warn} ${w}</div>`; });
            validation.passed.forEach(p => { html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} ${p}</div>`; });

            if (validation.orphanedSelectors?.length) {
                html += `<div class='spec-heading' style='margin-top:12px; padding-top:12px; border-top:1px solid var(--metadata-border);'><strong>Orphaned Selectors (not in DOM):</strong></div>`;
                    validation.orphanedSelectors.forEach(orphan => {
                    html += `
                        <div class="orphaned-item">
                            <div><strong>${orphan.key}</strong></div>
                            <div class="meta-text">Selector: <code>${orphan.selector}</code></div>
                            <div class="meta-text">JSON Path: <code>${orphan.jsonPath}</code></div>
                            ${orphan.data ? `<div class="muted-note"><strong>Data:</strong> <code>${JSON.stringify(orphan.data)}</code></div>` : ''}
                        </div>`;
                });
            }

            if (!html) html = '<div class="muted-italic">No validation data available</div>';
            return html;
        }

        renderInventoryList(validation) {
            const inv = validation.svgInventory || [];
            if (!inv.length) return '';

            const interactive = inv.filter(i => i.category === 'interactive');
            const text = inv.filter(i => i.category === 'text');
            const group = inv.filter(i => i.category === 'group');
            // Other: not in interactive, text, or group
            const other = inv.filter(i => i.category !== 'interactive' && i.category !== 'text' && i.category !== 'group');
            const overlay = inv.filter(i => i.category === 'overlay');
            const byCategory = {
                interactive,
                text,
                group,
                overlay,
                other
            };

            // Sort helper: JIM-mapped items first, then alphanumeric selector (numeric-aware)
            function sortByJIMThenSelector(a, b) {
                if (a.hasJIM !== b.hasJIM) return a.hasJIM ? -1 : 1;
                const sa = (a.selector || '').toString();
                const sb = (b.selector || '').toString();
                return sa.localeCompare(sb, undefined, { numeric: true, sensitivity: 'base' });
            }
            // Apply sort to each category to improve scanning in long SVGs
            Object.values(byCategory).forEach(arr => arr.sort(sortByJIMThenSelector));

            let html = `
                <h3 class="section-heading">
                    SVG Element Inventory
                    <div class="sr-only" aria-live="polite">This list is interactive. Use Tab to move between items and Enter to open details. Press 'i' to jump here from the visualization area. JIM and No JIM badges are announced for screen readers.</div>
                </h3>
            `;

            Object.entries(byCategory).forEach(([category, items]) => {
                if (!items.length) return;
                let label = category[0].toUpperCase() + category.slice(1) + ' Elements';
                if (category === 'other') label = 'Other Elements';
                html += `<h4 class="spec-heading">${label} (${items.length})</h4>`;

                // For click handlers we need the index within the underlying inventoryData's
                // same-category ordering. Compute that array so data-idx values match.
                const actualItems = inv.filter(i => i.category === category);

                // Split into JIM-mapped and not-mapped lists for clearer SR scanning
                const jimItems = items.filter(i => i.hasJIM);
                const noJimItems = items.filter(i => !i.hasJIM);

                function renderList(listItems, labelText) {
                    if (!listItems.length) return '';
                    let out = '';
                    out += `<h5 class="muted-note" role="heading" aria-level="5">${labelText} (${listItems.length})</h5>`;
                    out += '<div class="wrap-chips">';
                    listItems.forEach(item => {
                        const jimBadge = item.hasJIM
                            ? '<span class="badge badge--jim" aria-label="JIM mapped" role="status">JIM</span>'
                            : '<span class="badge badge--nojim" aria-label="No JIM mapping" role="status">No JIM</span>';
                        // Find the actual index within the underlying inventory ordering for this category
                        const actualIdx = actualItems.indexOf(item);
                        out += `
                            <button class="inventory-button" data-category="${category}" data-idx="${actualIdx}" aria-label="SVG element ${item.selector}${item.hasJIM ? ', JIM mapped' : ', No JIM mapping'}" role="button">
                                <div class="inline-row"><code class="inline-code">${item.selector}</code>${jimBadge}</div>
                                ${item.textContent ? `<div class="inline-text">Text: \"${item.textContent}\"</div>` : ''}
                                ${item.suggestions?.length ? `<div class="muted-note"><span class="sr-only">Suggestion: </span>${ICONS.idea} ${item.suggestions.join('; ')}</div>` : ''}
                            </button>`;
                    });
                    out += '</div>';
                    return out;
                }

                html += renderList(jimItems, 'JIM-mapped elements');
                html += renderList(noJimItems, 'No JIM mapping');
            });

            return html;
        }
            constructor() {
                this.jimData = null;
                this.currentDoc = null;
                this.infoPanel = document.getElementById('info-panel');
                this.infoContent = document.getElementById('info-content');
                this.inventoryData = [];
                this.detailedAnalysis = '';
                this.setupEventListeners();
            }

            renderAccessibilityAudit() {
                if (!this.currentDoc) return '<div class="muted-italic">No document to audit</div>';

                let svg = this.currentDoc.querySelector('svg');
                if (!svg && this.currentDoc.documentElement && this.currentDoc.documentElement.tagName.toLowerCase() === 'svg') {
                    svg = this.currentDoc.documentElement;
                }

                if (!svg) return '<div class="status-error-line">No SVG found in document</div>';

                const allElements = svg.querySelectorAll('*');
                let interactiveCount = 0;
                let textCount = 0;
                let accessibleCount = 0;
                let issues = [];

                allElements.forEach(el => {
                    const hasTabindex = el.hasAttribute('tabindex');
                    const hasARIA = el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby') || el.hasAttribute('aria-describedby');
                    const hasTitle = el.querySelector('title');
                    const isText = el.tagName.toLowerCase() === 'text';

                    if (isText) {
                        textCount++;
                        if (!el.hasAttribute('aria-hidden') && el.textContent.trim()) {
                            issues.push(`Text element "${el.textContent.trim().substring(0, 20)}..." might need aria-hidden if decorative`);
                        }
                    }

                    if (hasTabindex || hasARIA) {
                        interactiveCount++;
                        if (hasTabindex || hasARIA || hasTitle) {
                            accessibleCount++;
                        }
                    }

                    if (hasTabindex && !hasARIA && !hasTitle) {
                        issues.push(`Element ${el.tagName}${el.id ? '#' + el.id : ''} is keyboard accessible but lacks screen reader label`);
                    }
                });

                let html = '';
                html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} Found ${interactiveCount} interactive elements</div>`;
                html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} Found ${textCount} text elements</div>`;
                html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} ${accessibleCount} elements have accessibility labels</div>`;

                if (issues.length > 0) {
                    issues.slice(0, 3).forEach(issue => {
                        html += `<div class="status-warning-line"><span class="sr-only">Warning: </span>${ICONS.warn} ${issue}</div>`;
                    });
                    if (issues.length > 3) {
                        html += `<div class="muted-note italic">... and ${issues.length - 3} more issues</div>`;
                    }
                }

                // Inventory output removed; audit remains brief.

                return html;
            }

            renderSVGInventoryOnly() {
                if (!this.currentDoc) return '';

                let svg = this.currentDoc.querySelector('svg');
                if (!svg && this.currentDoc.documentElement && this.currentDoc.documentElement.tagName.toLowerCase() === 'svg') {
                    svg = this.currentDoc.documentElement;
                }

                const inventory = [];
                const allElements = svg.querySelectorAll('*');

                // Track which elements have already been categorized
                const categorized = new Set();

                // Text elements
                allElements.forEach(el => {
                    if (el.tagName.toLowerCase() === 'text') {
                        const item = this.createInventoryItem(el, false, 'text');
                        inventory.push(item);
                        categorized.add(el);
                    }
                });

                // Interactive elements
                allElements.forEach(el => {
                    const tag = el.tagName.toLowerCase();
                    // Skip text (handled above) and groups (handled in group pass)
                    if (tag === 'text' || tag === 'g') return;
                    const hasAccessibility = el.hasAttribute('tabindex') ||
                                           el.hasAttribute('role') ||
                                           el.hasAttribute('aria-label') ||
                                           el.hasAttribute('aria-labelledby') ||
                                           el.hasAttribute('aria-describedby');
                    if (hasAccessibility) {
                        const item = this.createInventoryItem(el, false, 'interactive');
                        inventory.push(item);
                        categorized.add(el);
                    }
                });

                // Group elements
                allElements.forEach(el => {
                    if (el.tagName.toLowerCase() === 'g' && (el.id || (el.className && el.className.baseVal))) {
                        const item = this.createInventoryItem(el, false, 'group');
                        inventory.push(item);
                        categorized.add(el);
                    }
                });

                // Other elements: basic shapes not already categorized
                const shapeTags = ['polygon', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'path'];
                allElements.forEach(el => {
                    const tag = el.tagName.toLowerCase();
                    if (shapeTags.includes(tag) && !categorized.has(el)) {
                        const item = this.createInventoryItem(el, false, 'other');
                        inventory.push(item);
                        categorized.add(el);
                    }
                });

                // Store inventory data for click handlers
                this.inventoryData = inventory;
                console.log('Stored non-JIM inventory data:', this.inventoryData.length, 'items');

                // Use the same rendering logic as JIM mode
                return this.renderInventoryList({ svgInventory: inventory });
                // ...existing code...
            }

            attachJIMBehavior(element, selectorKey) {
                element.addEventListener('focus', () => this.showElementInfo(selectorKey, 'focus', element));
                element.addEventListener('click', () => this.showElementInfo(selectorKey, 'click', element));
            }

            showElementInfo(selectorKey, eventType, element) {
        // --- CLEAN IMPLEMENTATION START ---
        const facets = this.jimData?.datasets?.[0]?.facets || {};
        const selector = this.jimData.selectors?.[selectorKey];
        if (!selector) return;

        // Find the element in the live visualization SVG
        let vizElement = null;
        try {
            const viz = document.getElementById('visualization');
            if (viz && selector.dom) {
                vizElement = viz.querySelector(selector.dom);
            }
        } catch (e) {
            vizElement = element;
        }
        if (!vizElement) vizElement = element;

        let html = '';
        const data = this.getDataFromJSONPath(selector.json);
        const defaultAnnouncement = this.getDefaultAnnouncement(data);
        // JIM-specific info
        html += `<div><strong>JIM Selector Key:</strong> <code>${selectorKey}</code></div>`;
        html += `<div><strong>Event:</strong> <code>${eventType}</code></div>`;
        if (this.jimData?.selectors?.[selectorKey]) {
            html += `<div><strong>DOM Selector:</strong> <code>${this.jimData.selectors[selectorKey].dom}</code></div>`;
            html += `<div><strong>JSON Path:</strong> <code>${this.jimData.selectors[selectorKey].json}</code></div>`;
            if (this.jimData.selectors[selectorKey].note) {
                html += `<div><strong>Note:</strong> ${this.jimData.selectors[selectorKey].note}</div>`;
            }
        }

        // Show all mapped behaviors for this element (including wildcards)
        const behaviors = this.jimData.behaviors || [];
        const matchedBehaviors = behaviors.filter(b => {
            const tgtSelector = b?.target?.selector;
            try {
                return tgtSelector && vizElement.matches(tgtSelector);
            } catch {
                return false;
            }
        });
        // Show explicit announcement box if present (use human-friendly format)
        let explicitAnn = null;
        for (const b of matchedBehaviors) {
            const ea = this.getExplicitAnnouncement(b);
            if (ea) { explicitAnn = ea; break; }
        }
        if (explicitAnn) {
            if (typeof explicitAnn === 'string') {
                html += `<div class="announcement announcement-success">
                    <strong>Explicit Announcement:</strong><br>${this.escapeHtml(explicitAnn)}
                </div>`;
            } else if (typeof explicitAnn === 'object') {
                const name = explicitAnn.name ? String(explicitAnn.name).trim() : null;
                const desc = explicitAnn.description ? String(explicitAnn.description).trim() : null;
                if (name || desc) {
                    html += `<div class="announcement announcement-success"><strong>Explicit Announcement:</strong><br>`;
                    if (name) html += `${this.escapeHtml(name)}`;
                    if (desc) html += `<div class="muted-note" style="margin-top:6px">${this.escapeHtml(desc)}</div>`;
                    html += `</div>`;
                }
            }
        }
        // Show default announcement box if present and different from explicit
        if (defaultAnnouncement && (!explicitAnn || (typeof explicitAnn === 'object' ? explicitAnn.description : explicitAnn) !== defaultAnnouncement)) {
            let facetNote = '';
            const facetsExist = !!this.jimData?.datasets?.[0]?.facets && Object.keys(this.jimData.datasets[0].facets).length > 0;
            if (facetsExist) {
                facetNote = `<div class="muted-note italic"><i>Note: Italicized fields are not covered by facet definitions.</i></div>`;
            }
            html += `<div class="announcement announcement-note">
                <strong>Default Announcement:</strong><br>${defaultAnnouncement}
                ${facetNote}
            </div>`;
        }
        // Show full JSON view of the first matched behavior if present
        if (matchedBehaviors.length) {
            html += `<details open class="details--spaced"><summary class="details-summary">Show/Hide Full Behavior JSON</summary><pre class="pre-meta meta-text">${JSON.stringify(matchedBehaviors[0], null, 2)}</pre></details>`;
        }

        // Accessibility attributes section
    html += '<h4 class="spec-heading">Accessibility Attributes</h4>';
    html += `<div><strong>aria-label:</strong> ${vizElement.getAttribute('aria-label') || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>aria-labelledby:</strong> ${vizElement.getAttribute('aria-labelledby') || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>aria-describedby:</strong> ${vizElement.getAttribute('aria-describedby') || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>role:</strong> ${vizElement.getAttribute('role') || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>tabindex:</strong> ${vizElement.getAttribute('tabindex') !== null ? vizElement.getAttribute('tabindex') : '<span class="muted">Not present</span>'}</div>`;

        let titleText = null;
        let descText = null;
        const titleEl = vizElement.querySelector('title');
        const titleAttr = vizElement.getAttribute('title');
        titleText = titleEl ? titleEl.textContent : titleAttr;
        const descEl = vizElement.querySelector('desc');
        descText = descEl ? descEl.textContent : null;
    html += `<div><strong>&lt;title&gt;:</strong> ${titleText || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>&lt;desc&gt;:</strong> ${descText || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>aria-hidden:</strong> ${vizElement.getAttribute('aria-hidden') || '<span class="muted">Not present</span>'}</div>`;
    html += `<div><strong>aria-live:</strong> ${vizElement.getAttribute('aria-live') || '<span class="muted">Not present</span>'}</div>`;

        // Computed styles section
        if (window.getComputedStyle && vizElement) {
            const computed = window.getComputedStyle(vizElement);
            html += '<h4 class="spec-heading">Computed Styles</h4>';

            // Local helpers to pick white or black neutral background for a color string
            function parseRgbLocal(str) {
                if (!str) return null;
                str = String(str).trim();
                let m;
                if (str.startsWith('rgb')) {
                    m = str.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                    if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
                }
                if (str[0] === '#') {
                    const hex = str.slice(1);
                    if (hex.length === 3) return [parseInt(hex[0]+hex[0],16), parseInt(hex[1]+hex[1],16), parseInt(hex[2]+hex[2],16)];
                    if (hex.length === 6) return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
                }
                return null;
            }

            function relLumLocal([r,g,b]){
                const srgb = [r,g,b].map(v => v/255).map(c => c <= 0.03928 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4));
                return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
            }

            function contrastLocal(a,b){ const L1 = relLumLocal(a); const L2 = relLumLocal(b); const light = Math.max(L1,L2); const dark = Math.min(L1,L2); return (light + 0.05) / (dark + 0.05); }

            function chooseBlackOrWhiteFor(colorStr) {
                const rgb = parseRgbLocal(colorStr);
                if (!rgb) return '#ffffff';
                const whiteContrast = contrastLocal(rgb, [255,255,255]);
                const blackContrast = contrastLocal(rgb, [0,0,0]);
                return (whiteContrast >= blackContrast) ? '#ffffff' : '#000000';
            }

            const fillStr = computed.fill || 'none';
            const strokeStr = computed.stroke || 'none';
            const fillBg = chooseBlackOrWhiteFor(fillStr);
            const strokeBg = chooseBlackOrWhiteFor(strokeStr);

                html += `<div><strong>fill:</strong> <span class="computed-dot-wrap" style="background:${fillBg};"><span aria-hidden="true" class="computed-dot-swatch" style="background:${fillStr};"></span></span> ${fillStr}</div>`;
                html += `<div><strong>stroke:</strong> <span class="computed-dot-wrap" style="background:${strokeBg};"><span aria-hidden="true" class="computed-dot-swatch" style="background:${strokeStr};"></span></span> ${strokeStr}</div>`;
            html += `<div><strong>stroke-width:</strong> ${computed.strokeWidth}</div>`;
            html += `<div><strong>opacity:</strong> ${computed.opacity}</div>`;
            html += `<div><strong>display:</strong> ${computed.display}</div>`;
            html += `<div><strong>visibility:</strong> ${computed.visibility}</div>`;
            html += `<div><strong>cursor:</strong> ${computed.cursor}</div>`;
            if (vizElement.tagName.toLowerCase() === 'text') {
                html += `<div><strong>font-size:</strong> ${computed.fontSize}</div>`;
                html += `<div><strong>font-family:</strong> ${computed.fontFamily}</div>`;
                html += `<div><strong>font-weight:</strong> ${computed.fontWeight}</div>`;
                const textContent = vizElement.textContent.trim();
                if (textContent) {
                    html += `<div class="inline-text"><strong>Text Content:</strong> \"${textContent}\"</div>`;
                }
            }
        }

    this.infoContent.innerHTML = html;
    try { if (window.enhanceComputedDots) window.enhanceComputedDots(this.infoContent); } catch (e) { /* ignore */ }
        this.infoPanel.classList.add('visible');
        // Update the live region for SR users after the panel is visible (one-frame delay)
        const liveRegion = document.getElementById('info-panel-live');
        if (liveRegion) {
            let label = `Element info panel opened for JIM selector ${selectorKey}`;
            liveRegion.textContent = '';
            requestAnimationFrame(() => {
                liveRegion.textContent = label;
            });
        }
        // --- CLEAN IMPLEMENTATION END ---

    }

            createInventoryItem(element, hasJIM, category) {
                const tag = element.tagName.toLowerCase();
                const id = element.id ? `#${element.id}` : '';
                const classes = element.classList.length ? '.' + [...element.classList].join('.') : '';
                
                // Create a more specific selector that includes position or attributes
                let selector = `${tag}${id}${classes}`;
                
                // For elements without unique IDs, add position-based specificity
                if (!element.id) {
                    const siblings = Array.from(element.parentNode.children).filter(el => 
                        el.tagName === element.tagName && 
                        el.className === element.className
                    );
                    
                    if (siblings.length > 1) {
                        const index = siblings.indexOf(element);
                        selector = `${tag}${classes}:nth-of-type(${index + 1})`;
                    }
                }
                
                const item = {
                    category,
                    selector,
                    element: tag,
                    hasJIM,
                    domElement: element, // Store reference to actual element
                    accessibility: {
                        tabindex: element.getAttribute('tabindex'),
                        role: element.getAttribute('role'),
                        ariaLabel: element.getAttribute('aria-label'),
                        ariaLabelledby: element.getAttribute('aria-labelledby'),
                        ariaDescribedby: element.getAttribute('aria-describedby'),
                        ariaHidden: element.getAttribute('aria-hidden'),
                        hasTitle: !!element.querySelector('title'),
                        hasDesc: !!element.querySelector('desc')
                    },
                    suggestions: []
                };

                if (tag === 'text') {
                    item.textContent = element.textContent.trim();
                }

                if (category === 'text' && !item.accessibility.ariaHidden && item.textContent) {
                    if (!hasJIM) {
                        item.suggestions.push('Consider aria-hidden="true" if decorative, or connect via aria-labelledby if meaningful');
                    }
                }

                if (category === 'interactive' && !hasJIM) {
                    item.suggestions.push('Interactive element lacks JIM mapping');
                }

                if (!item.accessibility.tabindex && !item.accessibility.role && category === 'interactive') {
                    item.suggestions.push('Has ARIA but no tabindex - may not be keyboard accessible');
                }

                if (item.accessibility.ariaLabelledby && !item.accessibility.tabindex) {
                    item.suggestions.push('Has aria-labelledby but no tabindex');
                }

                return item;
            }

            renderValidationResults(validation) {
                if (!validation) return '<div class="muted-italic">No validation data available</div>';
                let html = '';
                // Facet validation
                if (validation.facetSummary) {
                    if (validation.facetSummary.missing && validation.facetSummary.missing.length) {
                        html += `<div class="status-warning-line"><span class="sr-only">Warning: </span>${ICONS.warn} ${validation.facetSummary.missing.length} record properties lack facet definitions: ${validation.facetSummary.missing.join(', ')}</div>`;
                    } else if (validation.facetSummary.total > 0) {
                        html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} All record properties have facet definitions</div>`;
                    }
                }

                // Behavior validation: clarify mapping vs overlay-only behaviors
                if (validation.behaviorSummary) {
                    const totalSelectors = validation.behaviorSummary.total || 0;
                    const mappedCount = typeof validation.behaviorSummary.mapped === 'number' ? validation.behaviorSummary.mapped : 0;
                    const missing = validation.behaviorSummary.missing || [];
                    const shapeBehaviors = validation.behaviorSummary.shapeBehaviors || 0;
                    const behaviorCount = typeof validation.behaviorSummary.behaviorCount === 'number' ? validation.behaviorSummary.behaviorCount : 0;
                    const behaviorsWithoutSelectors = typeof validation.behaviorSummary.behaviorsWithoutSelectors === 'number' ? validation.behaviorSummary.behaviorsWithoutSelectors : 0;

                    // Selector coverage summary
                    if (totalSelectors > 0) {
                        if (mappedCount === totalSelectors) {
                            html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} All ${totalSelectors} selector(s) covered by behaviors</div>`;
                        } else if (mappedCount > 0) {
                            html += `<div class="status-success-line"><span class="sr-only">Info: </span>${ICONS.check} ${mappedCount} of ${totalSelectors} selector(s) covered by behaviors</div>`;
                        } else {
                            html += `<div class="status-success-line"><span class="sr-only">Info: </span>${ICONS.check} ${totalSelectors} selector(s) found, none covered by behaviors</div>`;
                        }
                    }

                    // Behavior count
                    if (behaviorCount === 0) {
                        html += `<div class="status-success-line"><span class="sr-only">Info: </span>${ICONS.info} No behaviors defined</div>`;
                    } else {
                        html += `<div class="status-success-line"><span class="sr-only">Info: </span>${ICONS.check} ${behaviorCount} behavior(s) defined</div>`;
                        
                        // Breakdown when there are multiple behavior types
                        const selectorBased = behaviorCount - shapeBehaviors - behaviorsWithoutSelectors;
                        const needsBreakdown = (shapeBehaviors > 0 || behaviorsWithoutSelectors > 0);
                        
                        if (needsBreakdown) {
                            const parts = [];
                            if (selectorBased > 0) parts.push(`${selectorBased} selector-based`);
                            if (shapeBehaviors > 0) parts.push(`${shapeBehaviors} shape-based`);
                            if (behaviorsWithoutSelectors > 0) parts.push(`${behaviorsWithoutSelectors} targeting non-selector elements`);
                            html += `<div class="status-success-line" style="margin-left:24px;">↳ ${parts.join(', ')}</div>`;
//                            html += `<div class="status-success-line" style="margin-left:24px;">${ICONS.arrowdown} ${parts.join(', ')}</div>`;
                        }
                    }
                }

                // Selector/DOM validation
                if (validation.selectorSummary) {
                    html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} ${validation.selectorSummary.domValid} DOM selector(s) valid</div>`;
                    html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} ${validation.selectorSummary.jsonValid} JSON path(s) valid</div>`;
                }
                // Errors, warnings, passes
                validation.errors?.forEach(err => {
                    html += `<div class="status-error-line"><span class="sr-only">Error: </span>${ICONS.cross} ${err}</div>`;
                });
                validation.warnings?.forEach(w => {
                    html += `<div class="status-warning-line"><span class="sr-only">Warning: </span>${ICONS.warn} ${w}</div>`;
                });
                validation.passed?.forEach(p => {
                    html += `<div class="status-success-line"><span class="sr-only">Success: </span>${ICONS.check} ${p}</div>`;
                });
                // Orphaned selectors (accessible heading and list)
                if (validation.orphanedSelectors?.length) {
                    html += '<h4 id="orphaned-selectors-heading" class="spec-heading" role="heading" aria-level="2">Orphaned Selectors (not in DOM)</h4>';
                    html += '<div class="sr-only" id="orphaned-selectors-sr-help">This is a static list of selectors defined in JIM metadata that do not match any element in the SVG. This list is not interactive. Press \'i\' again to move to the SVG Element Inventory, where you can use Tab and Enter to explore items.</div>';
                    html += '<ul aria-labelledby="orphaned-selectors-heading orphaned-selectors-sr-help" class="orphaned-list">';
                    validation.orphanedSelectors.forEach(orphan => {
                        html += `
                            <li class="orphaned-item">
                                <div><strong>${orphan.key}</strong></div>
                                <div class="meta-text">Selector: <code>${orphan.selector}</code></div>
                                <div class="meta-text">JSON Path: <code>${orphan.jsonPath}</code></div>
                                ${orphan.data ? `<div class="muted-note"><strong>Data:</strong> <code>${JSON.stringify(orphan.data)}</code></div>` : ''}
                            </li>`;
                    });
                    html += '</ul>';
                }
                if (!html) html = '<div class="muted-italic">No validation data available</div>';
                return html;
            }
        }
        // Ensure the JIMViewer is initialized when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.jimViewer = new JIMViewer();

            // Helper to update visible current file label
            function setCurrentFileLabel(text) {
                try {
                    const el = document.getElementById('current-file');
                    if (!el) return;
                    const full = String(text || 'No file loaded');
                    // Extract basename for display (strip path and query)
                    let path = full;
                    try {
                        // If it's an absolute URL, use URL to get pathname
                        const u = new URL(full, window.location.href);
                        path = u.pathname || full;
                    } catch (e) {
                        // not a full URL, keep as-is
                        path = full.split('?')[0];
                    }
                    path = path.replace(/\\/g, '/');
                    const parts = path.split('/').filter(Boolean);
                    let name = parts.length ? parts[parts.length - 1] : path;
                    if (!name) name = full;
                    // Display the full basename (CSS will visually ellipsize if needed)
                    el.textContent = name;
                    // Preserve full value in title for tooltip
                    el.setAttribute('title', full);
                } catch (e) { /* ignore */ }
            }

            // Helper: try fetching a path using several sensible URL variants (relative, absolute, origin-prefixed)
            async function tryFetchExampleWithVariants(path) {
                const variants = [];
                if (!path) return null;
                // Keep the original value first
                variants.push(path);
                // Ensure leading slash variant
                if (!path.startsWith('/')) variants.push('/' + path);
                // Origin-prefixed absolute URL
                try { variants.push(window.location.origin + (path.startsWith('/') ? path : '/' + path)); } catch (e) {}
                // Relative to current document
                variants.push('./' + path.replace(/^\/+/, ''));
                // Deduplicate while preserving order
                const seen = new Set();
                const uniq = variants.filter(v => { if (!v) return false; if (seen.has(v)) return false; seen.add(v); return true; });

                for (const candidate of uniq) {
                    try {
                        console.debug('[JIMViewer] attempting fetch for example candidate:', candidate);
                        const res = await fetch(candidate);
                        if (res && res.ok) {
                            const text = await res.text();
                            const ext = candidate.split('.').pop().toLowerCase();
                            return { text, ext, url: candidate };
                        } else {
                            console.debug('[JIMViewer] fetch returned non-ok for', candidate, res && res.status);
                        }
                    } catch (e) {
                        console.debug('[JIMViewer] fetch failed for', candidate, e && e.message ? e.message : e);
                    }
                }
                return null;
            }

            // Helper: populate the native file input from fetched text so the standard file dialog state
            // reflects the autoloaded example. This creates a Blob/File and assigns it to the input via
            // a DataTransfer object, then dispatches a change event so existing handlers run.
            async function populateNativeFileInputFromFetch(displayPath, text, ext) {
                try {
                    const input = document.getElementById('jim-file');
                    if (!input) return;

                    // Determine MIME type by extension
                    const mime = (ext === 'svg') ? 'image/svg+xml' : (ext === 'html' || ext === 'htm') ? 'text/html' : 'text/plain';

                    // Create a blob from the text and a File with a sensible filename
                    const filename = (function () {
                        try {
                            const u = new URL(displayPath, window.location.href);
                            return (u.pathname || '').split('/').pop() || ('example.' + ext);
                        } catch (e) {
                            const parts = String(displayPath || '').split('/').filter(Boolean);
                            return parts.length ? parts[parts.length - 1] : ('example.' + ext);
                        }
                    })();

                    const blob = new Blob([text], { type: mime });
                    let file;
                    try {
                        file = new File([blob], filename, { type: mime });
                    } catch (e) {
                        // Some older browsers may not support File constructor; fall back to Blob with name prop
                        file = blob;
                        file.name = filename;
                    }

                    // Use DataTransfer to set input.files
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    input.files = dt.files;

                    // Update visible label
                    setCurrentFileLabel(filename || displayPath || 'Autoloaded file');

                    // Dispatch change so existing listeners react (FileReader path)
                    const ev = new Event('change', { bubbles: true });
                    input.dispatchEvent(ev);
                } catch (e) {
                    console.warn('[JIMViewer] populateNativeFileInputFromFetch failed:', e);
                    throw e;
                }
            }

            // Auto-load example via query parameter, e.g. ?example=examples/testimage_0.svg
            (async function tryAutoLoadFromQuery() {
                try {
                    const params = new URLSearchParams(window.location.search);
                    const examplePath = params.get('example');
                    if (examplePath) {
                        const fetched = await tryFetchExampleWithVariants(examplePath);
                        if (fetched) {
                            // Try to populate the native file input so the standard file dialog state reflects the autoloaded file.
                            if (typeof populateNativeFileInputFromFetch === 'function') {
                                await populateNativeFileInputFromFetch(fetched.url || examplePath, fetched.text, fetched.ext);
                            } else {
                                // Fallback: directly handle the load and update label
                                window.jimViewer.handleFileLoad(fetched.text, fetched.ext);
                                setCurrentFileLabel(fetched.url || examplePath);
                            }
                        } else {
                            console.warn('[JIMViewer] Failed to fetch example from query param (all candidates failed):', examplePath);
                        }
                    }
                } catch (e) {
                    // ignore URL parsing errors in odd environments
                }
            })();

            // Listen for postMessage from an embedding harness (tests/auto-load.html)
            // Supports messages:
            //  - { type: 'autoLoadExample', path: '/examples/testimage_0.svg' }
            //  - { type: 'inspect', selector: 'svg #elemId' }
            window.addEventListener('message', async (ev) => {
                try {
                    // Only accept same-origin messages for safety in CI/local runs
                    if (!ev || ev.origin !== window.location.origin) return;
                    const data = ev.data || {};

                    // Auto-load example into the viewer (harness can postMessage { type: 'autoLoadExample', path })
                    if (data.type === 'autoLoadExample' && data.path) {
                        try {
                            const fetched = await tryFetchExampleWithVariants(data.path);
                            if (!fetched) {
                                console.warn('[JIMViewer] Failed to fetch auto-load path (all candidates failed):', data.path);
                                return;
                            }
                            if (window.jimViewer) {
                                if (typeof populateNativeFileInputFromFetch === 'function') {
                                    try {
                                        await populateNativeFileInputFromFetch(fetched.url || data.path, fetched.text, fetched.ext);
                                    } catch (e) {
                                        // fallback to direct load
                                        if (typeof window.jimViewer.handleFileLoad === 'function') window.jimViewer.handleFileLoad(fetched.text, fetched.ext);
                                        setCurrentFileLabel(fetched.url || data.path);
                                    }
                                } else if (typeof window.jimViewer.handleFileLoad === 'function') {
                                    window.jimViewer.handleFileLoad(fetched.text, fetched.ext);
                                    setCurrentFileLabel(fetched.url || data.path);
                                }
                            }
                        } catch (e) {
                            console.warn('[JIMViewer] Error fetching auto-load path:', e);
                        }
                        return;
                    }

                    // Inspect a CSS selector or JIM selector key inside the viewer's current visualization
                    if (data.type === 'inspect' && data.selector) {
                        try {
                            const viewer = window.jimViewer;
                            const originalSelector = String(data.selector);
                            const selectors = viewer?.jimData?.selectors || {};
                            let selectorKey = null;
                            let usedSelector = originalSelector;

                            // If the caller passed a JIM selector key (e.g. 'chartTitle'), map it to its dom value
                            if (selectors && Object.prototype.hasOwnProperty.call(selectors, originalSelector)) {
                                selectorKey = originalSelector;
                                usedSelector = selectors[originalSelector].dom || originalSelector;
                            }

                            // Try to find the element inside the live visualization using the chosen selector
                            let el = null;
                            try {
                                const viz = document.getElementById('visualization');
                                if (viz) el = viz.querySelector(usedSelector);
                            } catch (e) { el = null; }

                            // If nothing matched and the caller sent a plain token like 'chartTitle', try treating it as an id
                            if (!el && /^[A-Za-z0-9_\-]+$/.test(originalSelector)) {
                                try {
                                    const viz = document.getElementById('visualization');
                                    if (viz) {
                                        const idSel = '#' + originalSelector;
                                        el = viz.querySelector(idSel);
                                        if (el) usedSelector = idSel;
                                    }
                                } catch (e) { /* ignore */ }
                            }

                            if (el) {
                                // If we still don't have a selectorKey, try to find one by matching existing JIM selectors
                                if (!selectorKey && selectors) {
                                    for (const [key, sel] of Object.entries(selectors || {})) {
                                        try { if (el.matches(sel.dom)) { selectorKey = key; break; } } catch {}
                                    }
                                }

                                // Show the appropriate info panel using the viewer instance
                                if (viewer && typeof viewer.showElementInfo === 'function' && selectorKey) viewer.showElementInfo(selectorKey, 'external', el);
                                else if (viewer && typeof viewer.showNonJIMElementInfo === 'function' && !selectorKey) viewer.showNonJIMElementInfo(el, 'external');
                                else {
                                    // Fallback: log that viewer methods are unavailable
                                    console.warn('[JIMViewer] inspect: viewer instance not available to show info panel.');
                                }

                                // Send a response back to the sender so harness/CI can observe success
                                try {
                                    if (ev.source && ev.origin) {
                                        ev.source.postMessage({ type: 'inspect-result', matched: true, mapped: !!selectorKey, selector: originalSelector, usedSelector, selectorKey: selectorKey || null }, ev.origin);
                                    }
                                } catch (e) { /* ignore postMessage failures */ }
                            } else {
                                console.warn('[JIMViewer] inspect: selector did not match any element in visualization:', originalSelector);
                                try {
                                    if (ev.source && ev.origin) {
                                        ev.source.postMessage({ type: 'inspect-result', matched: false, selector: originalSelector }, ev.origin);
                                    }
                                } catch (e) { /* ignore postMessage failures */ }
                            }
                        } catch (e) {
                            console.warn('[JIMViewer] Error handling inspect message:', e);
                        }
                        return;
                    }
                } catch (e) {
                    // swallow any message handler errors
                }
            });
        });

        // Accessibility helper: replace small glyph dots used to show computed colors
        // with deterministic color swatches that have explicit background so axe can compute contrast.
        (function() {
            function parseRgb(str) {
                if (!str) return null;
                str = String(str).trim();
                let m;
                if (str.startsWith('rgb')) {
                    m = str.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                    if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
                }
                if (str[0] === '#') {
                    const hex = str.slice(1);
                    if (hex.length === 3) return [parseInt(hex[0]+hex[0],16), parseInt(hex[1]+hex[1],16), parseInt(hex[2]+hex[2],16)];
                    if (hex.length === 6) return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
                }
                return null;
            }

            function relLum([r,g,b]){
                const srgb = [r,g,b].map(v => v/255).map(c => c <= 0.03928 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4));
                return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
            }

            function contrast(a,b){ const L1 = relLum(a); const L2 = relLum(b); const light = Math.max(L1,L2); const dark = Math.min(L1,L2); return (light + 0.05) / (dark + 0.05); }

            function enhanceComputedDots(root=document) {
                try {
                    const dots = Array.from(root.querySelectorAll('.computed-dot'));
                    dots.forEach(dot => {
                        try {
                            const cs = window.getComputedStyle(dot);
                            let colorStr = cs.color || cs.fill || cs.backgroundColor || dot.getAttribute('data-color');
                            let rgb = parseRgb(colorStr);
                            // If color isn't parseable (e.g. 'none'), try to read adjacent text node that contains the textual color value
                            if (!rgb) {
                                const next = dot.nextSibling;
                                if (next && next.nodeType === Node.TEXT_NODE) {
                                    // e.g. ' rgb(96, 114, 169)'
                                    const txt = next.textContent && next.textContent.trim();
                                    // attempt to extract rgb(...) or #hex
                                    const m = txt && txt.match(/(rgba?\([^)]+\)|#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6}))/);
                                    if (m) rgb = parseRgb(m[1]);
                                }
                            }
                            if (!rgb) return;

                            // Build swatch element (match inline swatch sizing: 10px inner, 16px outer)
                            const swatch = document.createElement('span');
                            swatch.className = 'computed-dot-swatch';
                            swatch.setAttribute('aria-hidden', 'true');
                            swatch.style.display = 'block';
                            swatch.style.width = '10px';
                            swatch.style.height = '10px';
                            swatch.style.borderRadius = '50%';
                            swatch.style.backgroundColor = `rgb(${rgb.join(',')})`;

                            // Determine effective background at insertion point by walking up to the nearest
                            // ancestor with a non-transparent computed background. If none found, fall back to white.
                            function findEffectiveBackgroundColor(node) {
                                let cur = node && node.parentElement;
                                while (cur) {
                                    try {
                                        const bg = window.getComputedStyle(cur).backgroundColor;
                                        if (bg && bg !== 'transparent' && !bg.startsWith('rgba(0, 0, 0, 0)')) return bg;
                                    } catch (e) { /* ignore */ }
                                    cur = cur.parentElement;
                                }
                                return '#ffffff';
                            }
                            const effectiveBgStr = findEffectiveBackgroundColor(dot);
                            const effectiveBgRgb = parseRgb(effectiveBgStr) || [255,255,255];
                            const effContrast = contrast(rgb, effectiveBgRgb);
                            // Choose neutral background: prefer effective background if it gives >= 3:1 contrast,
                            // otherwise fall back to white/black that gives the best contrast.
                            const whiteContrast = contrast(rgb, [255,255,255]);
                            const blackContrast = contrast(rgb, [0,0,0]);
                            const wrap = document.createElement('span');
                            wrap.className = 'computed-dot-wrap';
                            if (effContrast >= 3) {
                                wrap.style.background = `rgb(${effectiveBgRgb.join(',')})`;
                            } else {
                                wrap.style.background = (whiteContrast >= blackContrast) ? '#ffffff' : '#000000';
                            }
                            // Match inline wrap sizing and spacing
                            wrap.style.width = '16px';
                            wrap.style.height = '16px';
                            wrap.style.borderRadius = '8px';
                            wrap.style.boxShadow = 'inset 0 0 0 1px rgba(0,0,0,0.06)';
                            wrap.style.display = 'inline-flex';
                            wrap.style.alignItems = 'center';
                            wrap.style.justifyContent = 'center';
                            wrap.style.marginRight = '8px';
                            wrap.style.verticalAlign = 'middle';
                            wrap.style.overflow = 'visible';

                            // Replace original dot with wrap containing swatch
                            dot.parentNode && dot.parentNode.replaceChild(wrap, dot);
                            wrap.appendChild(swatch);
                        } catch (e) { /* per-dot failures ignored */ }
                    });
                } catch (e) { /* ignore overall failures */ }
            }

            // Run after DOM ready and also expose on window for dynamic updates
            try { enhanceComputedDots(document); } catch (e) {}
            window.enhanceComputedDots = enhanceComputedDots;
        })();

        // Global function to handle inventory item clicks
        window.handleInventoryItemClick = function (category, idx) {
            if (!window.jimViewer || !window.jimViewer.inventoryData) return;
            // Find the item in the inventory by category and index
            const items = window.jimViewer.inventoryData.filter(i => i.category === category);
            const item = items[idx];
            if (!item) return;
            // If this is an overlay synthetic item, show behavior info
            if (category === 'overlay') {
                try {
                    // If domElement exists, focus it; otherwise render info directly
                    if (item.domElement) {
                        item.domElement.focus();
                        // Fire the viewer helper
                        const bi = item.behaviorIndex;
                        const si = item.shapeIndex;
                        const behavior = window.jimViewer.jimData?.behaviors?.[bi];
                        if (behavior && typeof window.jimViewer.showBehaviorInfo === 'function') {
                            window.jimViewer.showBehaviorInfo(behavior, 'select', item.domElement);
                            return;
                        }
                    } else {
                        const bi = item.behaviorIndex;
                        const behavior = window.jimViewer.jimData?.behaviors?.[bi];
                        if (behavior && typeof window.jimViewer.showBehaviorInfo === 'function') {
                            window.jimViewer.showBehaviorInfo(behavior, 'select', null);
                            return;
                        }
                    }
                } catch (e) { /* ignore overlay handler failures */ }
            }
            if (item && item.domElement) {
                if (item.hasJIM && window.jimViewer.jimData && window.jimViewer.jimData.selectors) {
                    // Try to find the selectorKey for this element
                    const selectors = window.jimViewer.jimData.selectors;
                    let selectorKey = null;
                    for (const [key, sel] of Object.entries(selectors)) {
                        try {
                            if (item.domElement.matches(sel.dom)) {
                                selectorKey = key;
                                break;
                            }
                        } catch { }
                    }
                    if (selectorKey) {
                        window.jimViewer.showElementInfo(selectorKey, 'click', item.domElement);
                        return;
                    }
                }
                // Fallback: show non-JIM info
                window.jimViewer.showNonJIMElementInfo(item.domElement, 'click');
            }
        };
    </script>
</body>
</html>